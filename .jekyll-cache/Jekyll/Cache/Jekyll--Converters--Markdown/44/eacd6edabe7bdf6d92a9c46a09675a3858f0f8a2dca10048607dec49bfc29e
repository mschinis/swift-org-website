I"Ò<p>Swift has language constructs that allow you to specify your programâ€™s expectations. If these expectations are not met at runtime, the program will be terminated. For example, <em>indexing into an array</em> implicitly expresses an expectation that the index is in bounds:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Program will terminate if 'index' less than 0 or greater than 'array.count - 1'.</span>
<span class="k">let</span> <span class="nv">element</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</code></pre></div></div>

<p>Another common operation that will terminate the program on failure is a <em>forced unwrap of an optional</em>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Program will terminate if 'self.navigationController' is nil.</span>
<span class="k">let</span> <span class="nv">nc</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">navigationController</span><span class="o">!</span>
</code></pre></div></div>

<p><em>Preconditions</em> are yet another example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Program will terminate if 'index' is less or equal to 0.</span>
<span class="nf">precondition</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"Index must be greater than zero."</span><span class="p">)</span>
</code></pre></div></div>

<p>When the expectations are incorrect or when thereâ€™s a bug in the code, Swift <em>guarantees</em> that the program will trap. Especially during development itâ€™s common that some precondition isnâ€™t met, the program terminates and the debugger will show that. However, prior to Xcode 9.1 (currently available as a beta), the debugger displayed these situations just as any other type of crash â€” usually as <code class="language-plaintext highlighter-rouge">EXC_BAD_INSTRUCTION</code> or <code class="language-plaintext highlighter-rouge">EXC_BREAKPOINT</code> (which are the low-level Mach exceptions types).</p>

<p>This has been a source of confusion for both beginners and seasoned developers. In Xcode 9.1 the display of fatal errors is significantly improved. When running under the debugger, Xcode will now show the <em>failure reason</em> in the editor where the trap occurred:</p>

<p><img src="https://swift.org/assets/images/fatal-errors/xcode-fatalerror.png" alt="Swift fatal error in Xcode 9.1" style="width: 100%;" /></p>

<p>Many events that trigger a runtime trap are covered, including:</p>

<ul>
  <li>forced unwrapping <code class="language-plaintext highlighter-rouge">nil</code></li>
  <li>forced-try expressions (<code class="language-plaintext highlighter-rouge">try!</code>) producing an error</li>
  <li>out-of-bounds indexing into arrays</li>
  <li>precondition failures</li>
  <li>assertion failures</li>
  <li><code class="language-plaintext highlighter-rouge">fatalError</code> calls</li>
</ul>

<p>Note that this improved experience is only available when the appâ€™s entry point is written in Swift (i.e. your app delegate with the <code class="language-plaintext highlighter-rouge">@UIApplicationMain</code>/<code class="language-plaintext highlighter-rouge">@NSApplicationMain</code> attribute).</p>

<p>Xcode 9.1 can be downloaded from <a href="https://developer.apple.com/download/">developer.apple.com</a> (currently a pre-release version, an official release will be available later this year).</p>
:ET