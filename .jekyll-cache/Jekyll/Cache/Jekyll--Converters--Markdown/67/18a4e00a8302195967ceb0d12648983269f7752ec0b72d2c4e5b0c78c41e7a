I"Cü<p>We‚Äôre thrilled to announce a new open-source package for the Swift on Server ecosystem, <a href="https://github.com/apple/swift-distributed-actors/">Swift Distributed Actors</a>, a complete server-oriented cluster library for the upcoming <code class="language-plaintext highlighter-rouge">distributed actor</code> language feature!</p>

<p>This library provides a complete solution for using distributed actors in server use-cases. By open-sourcing this project early, alongside the ongoing work on the language feature, we hope to gather more useful feedback on the shape of the language feature and associated transport implementations.</p>

<h3 id="distributed-actors-proposal">Distributed Actors Proposal</h3>

<p>Distributed actors are an early and <em>experimental language feature</em>.  We aim to simplify and push the state-of-the-art for distributed systems programming in Swift as we did with concurrent programming with local actors and Swift‚Äôs structured concurrency approach embedded in the language.</p>

<p>Currently, we are iterating on the design of distributed actors. We are looking to gather your feedback, use-cases, and general ideas in the proposal‚Äôs <a href="https://forums.swift.org/t/pitch-distributed-actors/51669">pitch thread</a>, as well as the <a href="https://forums.swift.org/c/server/distributed-actors/79">Distributed Actors category</a> on the Swift forums. The library and language feature described in the proposal and this blog post are available in <a href="https://swift.org/downloads">nightly toolchains</a>, so please feel free to download them and get a feel for the feature. We will be posting updated proposals and other discussion threads on the forums, so if you are interested, please follow the respective category and threads on the Swift forums.</p>

<p>We are most interested in general feedback, thoughts about use cases, and potential transport implementations you would be interested in taking on. As we mature and design the language feature, the library (introduced below) will serve as the <em>reference implementation</em> of one such advanced and powerful actor transport. If you are interested in distributed systems, <a href="https://github.com/apple/swift-distributed-actors/">contributions to the library</a> itself are also very welcome, and there is <a href="https://github.com/apple/swift-distributed-actors/issues">much to be done</a> there as well!</p>

<p>Soon, we will also provide a more complete ‚Äúreference guide,‚Äù examples, and article-style guides.  These materials, to be authored using the <a href="https://swift.org/blog/swift-docc/">recently open-sourced DocC</a> documentation compiler, will teach about the specific patterns and use-cases this library enables.</p>

<p>These proposed language features‚Äìas all language features‚Äìwill go through a proper <a href="https://github.com/apple/swift-evolution/blob/main/process.md">Swift Evolution process</a> before lifting their experimental status. We invite the community to participate and help us shape the language and APIs through review, contributions, and sharing experiences. Thank you very much in advance!</p>

<blockquote>
  <p>This project is released as ‚Äúearly preview‚Äù and all of its APIs are subject to change, or even removal without any prior warning.</p>
</blockquote>

<p>The library depends on un-released, work-in-progress, and Swift Evolution review pending language features. As such, we cannot recommend using it in production just yet ‚Äî the library may depend on specific nightly builds of toolchains, etc.</p>

<p>The primary purpose of open sourcing this library early is to prove the ability to implement a feature-complete, compelling clustering solution using the <code class="language-plaintext highlighter-rouge">distributed actor</code> language feature and co-evolving the two in tandem.</p>

<h3 id="distributed-actors-overview">Distributed Actors Overview</h3>

<p>Distributed actors are the next step in the evolution of <a href="https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html">Swift‚Äôs concurrency model</a>.</p>

<p>With actors built into the language, Swift offers developers a safe and intuitive concurrency model that is an excellent fit for many applications. Thanks to advanced semantic checks, the compiler can guide and help developers write programs free from low-level data races. These checks are not where the usefulness of the actor model ends, though: unlike other concurrency models, the actor model is also tremendously valuable for modeling distributed systems.  Thanks to the notion of <em>location transparent</em> distributed actors, we can program distributed systems using the familiar idea of actors and then readily move it to a distributed, e.g., clustered, environment.</p>

<p>With distributed actors, we aim to simplify and push the state of the art of distributed systems programming, the same way we did with concurrent programming with local actors and Swift‚Äôs structured concurrency models embedded in the language.</p>

<p>This abstraction does not intend to completely hide away the fact that distributed calls are crossing the network, though. In a way, we are doing the opposite and programming assuming that calls <em>may</em> be remote. This small yet crucial observation allows us to build systems primarily intended for distribution and testable in local test clusters that may even efficiently simulate various error scenarios.</p>

<p>Distributed actors are similar to (local) actors because they encapsulate their state with communication exclusively through asynchronous calls. The distributed aspect adds to that equation some additional isolation, type system, and runtime considerations. However, the surface of the feature feels very similar to local actors. Here is a small example of a distributed actor declaration:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>
<span class="c1">// 1) Actors may be declared with the new 'distributed' modifier</span>
<span class="n">distributed</span> <span class="kd">actor</span> <span class="kt">Worker</span> <span class="p">{</span>

  <span class="c1">// 2) An actor's isolated state is only stored on the node where the actor lives.</span>
  <span class="c1">//    Actor Isolation rules ensure that programs only access isolated state in</span>
  <span class="c1">//    correct ways, i.e. in a thread-safe manner, and only when the state is</span>
  <span class="c1">//    known to exist.</span>
  <span class="k">var</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">SomeData</span>

  <span class="c1">// 3) Only functions (and computed properties) declared as 'distributed' may be accessed cross actor.</span>
  <span class="c1">//    Distributed function parameters and return types must be Codable,</span>
  <span class="c1">//    because they will be crossing network boundaries during remote calls.</span>
  <span class="n">distributed</span> <span class="kd">func</span> <span class="nf">work</span><span class="p">(</span><span class="nv">item</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">WorkItem</span><span class="o">.</span><span class="kt">Result</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Distributed actors take away a lot of the boilerplate that we‚Äôd typically have to build and re-invent every time we create some distributed RPC system. After all, we did not care in the snippet about exact serialization and networking details; we declared what we needed to get done and sent work requests across the network! This omission of boilerplate is quite powerful, and we hope you‚Äôll enjoy using actors in this capacity, in addition to their concurrency aspect.</p>

<p>To have a distributed actor participate in some distributed system, we must provide it with an <code class="language-plaintext highlighter-rouge">ActorTransport</code>, a user-implementable library component responsible for performing all the networking necessary to make remote function calls. Developers offer their transport of choice during the instantiation of a distributed actor, like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="c1">// 4) Distributed actors must have a transport associated with them at initialization</span>
<span class="k">let</span> <span class="nv">someTransport</span><span class="p">:</span> <span class="kt">ActorTransport</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">let</span> <span class="nv">worker</span> <span class="o">=</span> <span class="kt">Worker</span><span class="p">(</span><span class="nv">transport</span><span class="p">:</span> <span class="n">someTransport</span><span class="p">)</span>

<span class="c1">// 5) Distributed function invocations are asynchronous and throwing, when performed cross-actor,</span>
<span class="c1">//    because of the potential network interactions of such call.</span>
<span class="c1">//</span>
<span class="c1">//    These effects are applied to such functions implicitly, only in contexts where necessary,</span>
<span class="c1">//    for example: when it is known that the target actor is local, the implicit-throwing effect</span>
<span class="c1">//    is not applied to such call.</span>
<span class="n">_</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">worker</span><span class="o">.</span><span class="nf">work</span><span class="p">(</span><span class="nv">item</span><span class="p">:</span> <span class="s">"work-item-32"</span><span class="p">)</span>

<span class="c1">// 6) Remote systems may obtain references to the actor by using the 'resolve' function.</span>
<span class="c1">//    It returns a special "proxy" object, that transforms all distributed function calls into messages.</span>
<span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="kt">Worker</span><span class="o">.</span><span class="nf">resolve</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="nv">using</span><span class="p">:</span> <span class="n">otherTransport</span><span class="p">)</span>
</code></pre></div></div>

<p>This post summarizes the distributed actor feature at a very high level. We encourage those interested to read the full proposal available in <a href="https://github.com/apple/swift-evolution/pulls?q=is%3Apr+is%3Aopen+distributed">Swift Evolution</a>, and provide feedback or ask questions in the <a href="https://forums.swift.org/c/server/distributed-actors/79">Distributed Actors category on the Swift Forums</a>.</p>

<p>You can follow along and provide feedback on the <code class="language-plaintext highlighter-rouge">distributed actor</code> language proposal on the Swift forums and <a href="https://github.com/apple/swift-evolution/pulls?q=is%3Apr+is%3Aopen+distributed">Swift Evolution</a>. The <a href="https://github.com/apple/swift-evolution/pull/1433">current, complete draft</a> is also available for review, though we expect to make significant changes to it shortly.</p>

<p>We would love to hear your feedback and see you participate in the Swift Evolution reviews of this exciting new feature!</p>

<h3 id="distributed-actor-transport-implementations">Distributed Actor Transport Implementations</h3>

<p>The Swift standard library itself does not provide any specific transport. Instead, it focuses on defining the language model and extension points that transport implementations can use to implement particular transports for distributed actors.</p>

<p>We intend to enable new and exciting transport implementations. The standard library defines an <code class="language-plaintext highlighter-rouge">ActorTransport</code> protocol, which anyone may implement to utilize distributed actors in unique and compelling use cases. Examples of potential transport implementations include, but are not limited to, clustered systems, web-socket-based messaging, or even inter-process communication for distributed actors.</p>

<p>Building an actor transport is not a trivial task, and we only expect a handful of mature implementations to take the stage eventually.</p>

<h2 id="introducing-distributed-actors-cluster-transport">Introducing: Distributed Actors Cluster Transport</h2>

<p>Today, we are announcing the open source release of the <a href="https://github.com/apple/swift-distributed-actors">Swift Distributed Actors library</a> - a fully featured framework for building distributed systems Swift. It is an implementation of the above mentioned <code class="language-plaintext highlighter-rouge">ActorTransport</code> protocol, and can serve as a reference implementation for other transport authors.</p>

<p>This cluster library is focused on server-side peer-to-peer systems, which are often used in systems which require ‚Äúlive‚Äù interactions with multiple parties, such as: presence systems, game lobbies, monitoring or IoT systems, and classical ‚Äúcontrol plane‚Äù systems such as orchestrators, schedulers, etc.</p>

<p>The library makes use of <a href="https://github.com/apple/swift-nio">SwiftNIO</a>, Swift‚Äôs high-performance server-side focused networking library, to implement the cluster‚Äôs networking layer. The cluster also provides a membership service, based on the <a href="https://swift.org/blog/swift-cluster-membership/">Swift Cluster Membership</a> library which was open sourced earlier last year. This means you can use this cluster in a stand-alone mode, without needing to spin up additional service discovery or database services. We believe this is an important capability as it simplifies deployment in some bare-metal scenarios, and makes utilizing this cluster technology viable in others where it otherwise might not have been possible due to resource constraints.</p>

<p>The cluster is designed to be very extensible, and it is possible to bring your own implementations of most of the core components, including node discovery, failure detection and more.</p>

<p>The distributed actor system enables actors to form a cluster, discover each other and communicate with one another without the need for low-level network programming that would otherwise be necessary. In the next sections we‚Äôll showcase some of the basic steps one would take to build such distributed actor system.</p>

<h3 id="forming-clusters">Forming Clusters</h3>

<p>For distributed actors to live up to their name, let us focus on a multi-node scenario right away. We‚Äôll start two nodes and have them form a cluster. The code snippets perform this task in one and the same process, but of course the intent of such system is to eventually run across multiple independent machines. Doing so isn‚Äôt all that different, and we‚Äôll discuss this a bit later.</p>

<p>The ability to create multiple cluster nodes in the same process highlights another useful capability of the cluster: it is possible to write your distributed system tests in-process, and either have them communicate in memory or communicate over an actual network - the only difference between those two cases is the transport passed to each actor. This allows us to develop distributed actors <em>once</em>, and then test, run, and deploy the same code but in slightly different configurations. We can run the same set of distributed actors in either:</p>

<ul>
  <li>single node cluster, using a single process - only <em>pretending</em> to be distributed, which can be useful for early and local development,</li>
  <li>multiple cluster nodes, but sharing the same process - which is useful in testing, as we can write <em>unit tests</em> for our distributed system, and have it use the actual networking, or even a transport simulating message loss or delays,</li>
  <li>multiple cluster nodes, on actual different physical machines - which is the usual deployment strategy for such systems in production.</li>
</ul>

<p>Forming clusters needs <em>some</em> knowledge about where other nodes of the clusters can be found. First, let us show the same-process but many nodes way of forming a cluster, as this is what one frequently uses in local testing:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="kt">ActorSystem</span><span class="p">(</span><span class="s">"FirstNode"</span><span class="p">)</span> <span class="p">{</span> <span class="n">settings</span> <span class="k">in</span>
  <span class="n">settings</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="nf">enable</span><span class="p">(</span><span class="nv">host</span><span class="p">:</span> <span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="nv">port</span><span class="p">:</span> <span class="mi">7337</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">second</span> <span class="o">=</span> <span class="kt">ActorSystem</span><span class="p">(</span><span class="s">"SecondNode"</span><span class="p">)</span> <span class="p">{</span> <span class="n">settings</span> <span class="k">in</span>
  <span class="n">settings</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="nf">enable</span><span class="p">(</span><span class="nv">host</span><span class="p">:</span> <span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="nv">port</span><span class="p">:</span> <span class="mi">8228</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">first</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="nf">join</span><span class="p">(</span><span class="nv">host</span><span class="p">:</span> <span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="nv">port</span><span class="p">:</span> <span class="mi">8228</span><span class="p">)</span>
<span class="c1">// or convenience API for local testing:</span>
<span class="c1">// first.cluster.join(node: second.settings.cluster.node)</span>
</code></pre></div></div>

<p>The actor system exposes many useful functions regarding the cluster state and actions it can perform via the <code class="language-plaintext highlighter-rouge">.cluster</code> property, such as <code class="language-plaintext highlighter-rouge">joining</code> other nodes into the cluster.</p>

<p>If the cluster already has multiple nodes, it is only necessary for a single node to join a new node for all the other nodes to eventually learn about this new node. Membership information is gossiped throughout the cluster automatically.</p>

<p>In a production system, we wouldn‚Äôt be hardcoding the joining process like this. Production deployments usually have some form of service discovery of nodes available, and thanks to <a href="https://swift.org/blog/swift-service-discovery/">Swift Service Discovery</a> we can easily utilize those to discover and automatically join nodes into our cluster. Swift Service Discovery provides an abstract API over discovery mechanisms, and can support backends such as DNS records or Kubernetes service discovery. We could use a hypothetical DNS discovery mechanism to discover the nodes:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="k">let</span> <span class="nv">third</span> <span class="o">=</span> <span class="kt">ActorSystem</span><span class="p">(</span><span class="s">"Third"</span><span class="p">)</span> <span class="p">{</span> <span class="n">settings</span> <span class="k">in</span>
  <span class="n">settings</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="nf">enable</span><span class="p">()</span>
  <span class="n">settings</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">discovery</span> <span class="o">=</span> <span class="kt">ServiceDiscoverySettings</span><span class="p">(</span>
    <span class="kt">SomeExistingDNSBasedServiceDiscovery</span><span class="p">(),</span> <span class="c1">// or any other swift-service-discovery mechanism</span>
    <span class="nv">service</span><span class="p">:</span> <span class="s">"my-actor-cluster"</span> <span class="c1">// `Service` type aligned with what DNSBasedServiceDiscovery expects</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// automatically joins all nodes that DNSBasedServiceDiscovery finds for "my-actor-cluster"</span>
</code></pre></div></div>

<p>This configuration would cause the system to periodically query DNS for service records and attempt joining any newly discovered nodes to our cluster.</p>

<h3 id="discovering-distributed-actors">Discovering Distributed Actors</h3>

<p>A common question when first learning about distributed actors is ‚ÄúHow do I <em>find</em> a remote actor?‚Äù since in order to obtain a remote reference, we need to obtain a specific <code class="language-plaintext highlighter-rouge">ActorIdentity</code> to be provided to the runtime, yet it is impossible to ‚Äújust guess‚Äù the right identifier of a remote actor.</p>

<p>Thankfully, the cluster comes with a solution to this problem! We call it the <code class="language-plaintext highlighter-rouge">Receptionist</code> pattern - because similar to a hotel, actors need to check-in (and out) at the reception in order for others to be able to find them. This check-in is optional and not automatic, by design, as not all distributed actors necessarily want to advertise their existence to <em>all</em> other actors, but only to a few select ones they know and trust etc.</p>

<p>The receptionist is interacted with from both sides, the actor registering with it, and an actor who is interested in listening to updates of a specific reception key.</p>

<p>First, let‚Äôs see how a distributed actor can advertise itself in the cluster under a known reception key:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>
<span class="n">distributed</span> <span class="kd">actor</span> <span class="kt">FamousActor</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">transport</span><span class="p">:</span> <span class="kt">ActorSystem</span><span class="p">)</span> <span class="k">async</span> <span class="p">{</span>
    <span class="k">await</span> <span class="n">transport</span><span class="o">.</span><span class="n">receptionist</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">withKey</span><span class="p">:</span> <span class="o">.</span><span class="n">famousActors</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">DistributedReception</span><span class="o">.</span><span class="kt">Key</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="k">var</span> <span class="nv">famousActors</span><span class="p">:</span> <span class="k">Self</span><span class="o">&lt;</span><span class="kt">FamousActor</span><span class="o">&gt;</span> <span class="p">{</span> <span class="s">"famous-actors"</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As we register a specific actor with the receptionist, it will automatically gossip this information across the network with other nodes in the cluster, and ensure all nodes are aware of this famous actor.</p>

<p>On other nodes of the cluster we can listen to updates about the famous actors key, and we‚Äôd simply be notified when new actors become known in the cluster. Here we use Swift‚Äôs <code class="language-plaintext highlighter-rouge">AsyncSequence</code> feature to consume this potentially infinite stream of updates:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** SYNTAX BASED ON CURRENT PROPOSAL TEXT AND LIBRARY -- NOT FINAL APIs ****</span>
<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">famousActor</span> <span class="k">in</span> <span class="n">transport</span><span class="o">.</span><span class="n">receptionist</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="o">.</span><span class="n">famousActors</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Oh, a new famous actor appeared: </span><span class="se">\(</span><span class="n">famousActor</span><span class="o">.</span><span class="n">id</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
  <span class="c1">// we can use the famousActor right away and send messages to it</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is also possible to ask the receptionist for a single, or all actors known under a specific key, rather than subscribing to updates.</p>

<p>The receptionist pattern gives us a type-safe way to advertise and discover actors, without having to worry about the exact networking details of how we‚Äôd achieve this.</p>

<h3 id="reacting-to-cluster-and-actor-lifecycle-events">Reacting to Cluster and Actor Lifecycle Events</h3>

<p>The cluster provides the ability to reason about the lifecycle of actors, regardless if they are co-located on the same, or on some remote compute node. This feature is surfaced as allowing distributed actors to ‚Äúwatch‚Äù each other for termination.</p>

<p>Whenever a watched actor is deinitialized, or the node on which it was running is determined ‚Äúdown‚Äù, a terminated signal is emitted about this actor, to any actors which were watching its lifecycle. The cluster uses the <a href="https://www.github.com/apple/swift-cluster-membership">Swift Cluster Membership</a> library which was open sourced earlier last year to detect nodes failing, and it moves them along a lifecycle graph as shown below:</p>

<p><img src="https://swift.org/assets/images/distributed-blog/cluster_lifecycle.png" alt="Cluster lifecycle diagram" /></p>

<p>Cluster events are emitted as an <code class="language-plaintext highlighter-rouge">AsyncSequence&lt;Cluster.Event&gt;</code>. Such sequence always begins with a ‚Äúsnapshot‚Äù of the current state of the cluster, followed by any changes that occur since that moment. This could be used to implement a function that waits until the cluster reaches a certain size for example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="k">var</span> <span class="nv">membership</span><span class="p">:</span> <span class="kt">Membership</span> <span class="o">=</span> <span class="o">.</span><span class="n">empty</span>

<span class="c1">// "infinite" stream of cluster events</span>
<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">event</span> <span class="k">in</span> <span class="n">system</span><span class="o">.</span><span class="n">cluster</span><span class="o">.</span><span class="n">events</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Cluster event: </span><span class="se">\(</span><span class="n">event</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

  <span class="c1">// events can be applied to membership to</span>
  <span class="k">try</span> <span class="n">membership</span><span class="o">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">membership</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="nv">atLeast</span><span class="p">:</span> <span class="o">.</span><span class="n">up</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">{</span> <span class="c1">// membership has useful utility functions</span>
    <span class="k">break</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could also inspect the specific events if desired. Refer to the documentation of <code class="language-plaintext highlighter-rouge">Cluster.Membership</code> to learn more about all the types of events and information available to you about the cluster state.</p>

<p>This isn‚Äôt the level of API most developers will be interacting with though. The actor cluster automatically translates relevant events to actor lifecycle signals, so instead of listening for cluster events every time we want to monitor an actor‚Äôs lifecycle, we can monitor <em>specific</em> actors, and in case the entire node the actor was located on is terminated, we‚Äôll get notified about that too. This feature is called <code class="language-plaintext highlighter-rouge">LifecycleWatch</code> and is used as follows:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="c1">// distributed actor Person {}</span>
<span class="k">let</span> <span class="nv">other</span><span class="p">:</span> <span class="kt">Person</span>
<span class="k">let</span> <span class="nv">system</span><span class="p">:</span> <span class="kt">ActorSystem</span>

<span class="nf">watchTermination</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="n">terminatedIdentity</span> <span class="k">in</span>
  <span class="n">system</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"Actor terminated: </span><span class="se">\(</span><span class="n">terminatedIdentity</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is important that the watch API does not retain the actor, and thus won‚Äôt keep it alive - otherwise the the termination would never be observed after all.</p>

<p>Distributed actors may need to keep themselfes alive by storing strong references to them in some kind of ‚Äúmanager‚Äù actor, some registry, or having the receptionist retain them (e.g. until they unregister, or some other condition happens).</p>

<h3 id="example-distributed-worker-pool">Example: Distributed Worker Pool</h3>

<p>Finally, we can put all those features together and show how to build a sample distributed worker pool utilizing the actor cluster.</p>

<p>Thanks to the cluster‚Äôs service discovery and failure detection mechanisms, we do not need to implement anything special in order to add new nodes as they are added to the cluster, or remove them as they are terminated. Instead, we can focus on the actors themselves, as the cluster mechanisms will automatically translate cluster events into respective events about the distributed actors.</p>

<p>First, let us prepare a <code class="language-plaintext highlighter-rouge">WorkerPool</code> distributed actor. It will subscribe to the receptionist with a worker key, and add all workers which appear in the cluster to the pool. As they terminate, it removes them from the pool it maintains.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="kd">extension</span> <span class="kt">Reception</span><span class="o">.</span><span class="kt">Key</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="k">var</span> <span class="nv">workers</span><span class="p">:</span> <span class="k">Self</span><span class="o">&lt;</span><span class="kt">Worker</span><span class="o">&gt;</span> <span class="p">{</span> <span class="s">"workers"</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">distributed</span> <span class="kd">actor</span> <span class="kt">WorkerPool</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">workers</span><span class="p">:</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">Worker</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">transport</span><span class="p">:</span> <span class="kt">ActorSystem</span><span class="p">)</span> <span class="k">async</span> <span class="p">{</span>
    <span class="kt">Task</span> <span class="p">{</span>
      <span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">worker</span> <span class="k">in</span> <span class="n">transport</span><span class="o">.</span><span class="n">receptionist</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="o">.</span><span class="n">workers</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">workers</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
        <span class="nf">watchTermination</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">worker</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">workers</span><span class="o">.</span><span class="nf">remove</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="c1">// thread-safe!</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">distributed</span> <span class="kd">func</span> <span class="nf">submit</span><span class="p">(</span><span class="n">work</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">WorkItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">worker</span> <span class="o">=</span> <span class="n">workers</span><span class="o">.</span><span class="n">shuffled</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">NoWorkersAvailable</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">try</span> <span class="k">await</span> <span class="n">worker</span><span class="o">.</span><span class="nf">work</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="n">item</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">WorkerPool</code> also reaps the usual benefits from being an <code class="language-plaintext highlighter-rouge">actor</code>, in addition to being a <em>distributed</em> actor: we can safely modify the <code class="language-plaintext highlighter-rouge">workers</code> variable without having to care or worry about threading ‚Äî the actor guarantees the concurrency safety of this property thanks to actor isolation.</p>

<p>The worker pool uses two cluster features: the receptionist to discover new workers, and the lifecycle watching in order to remove them as they terminate. This is enough to implement a fully managed set of peers, that will be dynamically updated as worker nodes join and leave the cluster.</p>

<p>The worker implementation is pretty short as well. We need to ensure that all <code class="language-plaintext highlighter-rouge">Worker</code> actors register themselves with the receptionist as they become initialized, so we‚Äôll do this in the actor‚Äôs asynchronous initializer. We don‚Äôt need to do anything else for the receptionist to automatically make a reference to this worker available in the cluster. When the worker deinitializes, or the entire node it was running on crashes, the receptionists on the other systems will automatically translate this into termination signals on their respective systems.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// **** APIS AND SYNTAX ARE WORK IN PROGRESS / PENDING SWIFT EVOLUTION ****</span>

<span class="n">distributed</span> <span class="kd">actor</span> <span class="kt">Worker</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">transport</span><span class="p">:</span> <span class="kt">ActorSystem</span><span class="p">)</span> <span class="k">async</span> <span class="p">{</span>
    <span class="k">await</span> <span class="n">transport</span><span class="o">.</span><span class="n">receptionist</span><span class="o">.</span><span class="nf">register</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">withKey</span><span class="p">:</span> <span class="o">.</span><span class="n">workers</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">distributed</span> <span class="kd">func</span> <span class="nf">work</span><span class="p">(</span><span class="n">on</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">WorkItem</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="p">{</span>
    <span class="c1">// do the work</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That‚Äôs it! The receptionist will automatically gossip with other peers in the cluster about the new worker instance joining the reception under the workers key. Any other actor in the cluster which subscribes to the receptionist‚Äôs updates can then discover these actors and contact them.</p>

<p>You also may have noticed that we did not have to deep dive into implementing any networking, request/reply matching or even any encoding/decoding from some wire format. All this is handled by the language feature in collaboration with the ActorSystem transport implementation. There are ways to customize many aspects of these, however in the simple case ‚Äî we don‚Äôt need to worry about it!</p>

<p>So, other than the system initialization (configuring node discovery), this really is all the code you need to write to prepare a distributed worker pool. We hope this small example has inspired you and given you a rough idea what kinds of use cases this feature enables. There is much more to learn and discover about distributed actors, but for now we‚Äôll leave it at that.</p>

<h3 id="resources">Resources</h3>

<ul>
  <li><a href="https://github.com/apple/swift-evolution/pull/1433">Swift Evolution: Distributed Actors Pitch, revision #1</a></li>
  <li><a href="https://github.com/apple/swift-distributed-actors">Swift Distributed Actors Library repository</a></li>
  <li><a href="https://forums.swift.org/c/server/distributed-actors/79">Distributed Actors category on Swift Forums</a></li>
</ul>
:ET