I"ª3<p>As part of Swiftâ€™s move toward safe, simple, and performant asynchronous programming, we are pleased to introduce a new package of algorithms for <code class="language-plaintext highlighter-rouge">AsyncSequence</code>. It is called <strong>Swift Async Algorithms</strong> and it is available now <a href="https://github.com/apple/swift-async-algorithms">on GitHub</a>.</p>

<p>This package has three main goals:</p>

<ul>
  <li>First-class integration with <code class="language-plaintext highlighter-rouge">async/await</code></li>
  <li>Provide a home for time-based algorithms</li>
  <li>Be cross-platform and open source</li>
</ul>

<h2 id="motivation">Motivation</h2>

<p>AsyncAlgorithms is a package for algorithms that work with <em>values over time</em>. That includes those primarily about <em>time</em>, like <code class="language-plaintext highlighter-rouge">debounce</code> and <code class="language-plaintext highlighter-rouge">throttle</code>, but also algorithms about <em>order</em> like <code class="language-plaintext highlighter-rouge">combineLatest</code> and <code class="language-plaintext highlighter-rouge">merge</code>. Operations that work with multiple inputs (like <code class="language-plaintext highlighter-rouge">zip</code> does on <code class="language-plaintext highlighter-rouge">Sequence</code>) can be surprisingly complex to implement, with subtle behaviors and many edge cases to consider. A shared package can get these details correct, with extensive testing and documentation, for the benefit of all Swift apps.</p>

<p>The foundation for AsyncAlgorithms is already included in Swift 5.5 in <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md">AsyncSequence</a>. Swift 5.5 also brings the ability to use a natural <code class="language-plaintext highlighter-rouge">for/in</code> loop with <code class="language-plaintext highlighter-rouge">await</code> to process the values in an <code class="language-plaintext highlighter-rouge">AsyncSequence</code> and <code class="language-plaintext highlighter-rouge">Sequence</code>-equivalent API like <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code>. Structured concurrency allows us to write code where intermediate state is simply a local variable, <code class="language-plaintext highlighter-rouge">try</code> can be used directly on functions that <code class="language-plaintext highlighter-rouge">throw</code>, and generally treat the logic for asynchronous code similar to that of synchronous code.</p>

<p>We believe an open source package will provide a great home for these APIs. A package gives developers flexibility in deploying across both platforms and OS versions. Development and API design will take place on <a href="https://github.com/apple/swift-async-algorithms">GitHub</a> and the <a href="https://forums.swift.org/c/related-projects/swift-async-algorithms/86">Swift Forums</a>.</p>

<h2 id="a-brief-tour">A Brief Tour</h2>

<p>The package includes <code class="language-plaintext highlighter-rouge">AsyncSequence</code> versions of familiar algorithms such as:</p>

<ul>
  <li>Zip</li>
  <li>CombineLatest</li>
  <li>Merge</li>
  <li>Chain</li>
  <li>Buffer</li>
  <li>Debounce</li>
  <li>Throttle</li>
</ul>

<hr />

<p>Letâ€™s start with a look at <code class="language-plaintext highlighter-rouge">zip</code>. Like its <code class="language-plaintext highlighter-rouge">Sequence</code> counterpart, <code class="language-plaintext highlighter-rouge">zip</code> produces tuples made up of values from two different <code class="language-plaintext highlighter-rouge">AsyncSequence</code>s:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="nf">await</span> <span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">letter</span><span class="p">)</span> <span class="k">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">letters</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">letter</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">AsyncSequence</code> supports <code class="language-plaintext highlighter-rouge">rethrows</code>, which means that error handling is as simple as using <code class="language-plaintext highlighter-rouge">try</code> â€“ the same as any other Swift code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">for</span> <span class="k">try</span> <span class="nf">await</span> <span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">letter</span><span class="p">)</span> <span class="k">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">lettersWithErrors</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">letter</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="c1">// Handle error</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Other algorithms like <code class="language-plaintext highlighter-rouge">combineLatest</code> and <code class="language-plaintext highlighter-rouge">merge</code> also combine the output of several <code class="language-plaintext highlighter-rouge">AsyncSequence</code>s. Each offers a different kind of control over the type and timing of the output.</p>

<hr />

<p>A fundamental difference between <code class="language-plaintext highlighter-rouge">Sequence</code> and <code class="language-plaintext highlighter-rouge">AsyncSequence</code> is the introduction of the variable of <em>time</em>. Building on top of <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0329-clock-instant-duration.md">proposals to standardize Clock and Duration</a>, the package adds algorithms like <code class="language-plaintext highlighter-rouge">debounce</code> and <code class="language-plaintext highlighter-rouge">throttle</code>. They provide easy, out-of-the-box solutions for common operations like throwing away values that arrive too fast:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="k">await</span> <span class="n">value</span> <span class="k">in</span> <span class="n">input</span><span class="o">.</span><span class="nf">debounce</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="nf">seconds</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Handle input, at most once per 0.5 seconds.</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p>It is often useful to wait for the collection of all values in a finite asynchronous sequence. This package provides initializers that do this with a single line of code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="k">await</span> <span class="kt">Array</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<p>The <code class="language-plaintext highlighter-rouge">async</code> function is useful for combining synchronous <code class="language-plaintext highlighter-rouge">Sequence</code>s with <code class="language-plaintext highlighter-rouge">AsyncSequence</code>. Here, we use it alongside the <code class="language-plaintext highlighter-rouge">chain</code> function to add a preamble to the contents of a file:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">preamble</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"// This source file is part of the Swift.org open source project"</span>
    <span class="s">"//"</span>
    <span class="s">""</span>
<span class="p">]</span><span class="o">.</span><span class="k">async</span>

<span class="k">let</span> <span class="nv">lines</span> <span class="o">=</span> <span class="nf">chain</span><span class="p">(</span><span class="n">preamble</span><span class="p">,</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">fileURLWithPath</span><span class="p">:</span> <span class="s">"/tmp/Sample.swift"</span><span class="p">)</span><span class="o">.</span><span class="n">lines</span><span class="p">)</span>

<span class="k">for</span> <span class="k">try</span> <span class="k">await</span> <span class="n">line</span> <span class="k">in</span> <span class="n">lines</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="combine">Combine</h2>

<p>Apple introduced the <a href="https://developer.apple.com/documentation/combine/">Combine</a> framework in the iOS 13 and macOS 10.15 SDKs. Since then, weâ€™ve had the opportunity to learn how Combine has been used in real-world scenarios. With AsyncAlgorithms, we are applying these lessons as well as embracing the new structured concurrency features of Swift.</p>

<p>Combineâ€™s API is based on the <code class="language-plaintext highlighter-rouge">Publisher</code> and <code class="language-plaintext highlighter-rouge">Subscriber</code> interfaces, with <em>operators</em> to connect between them. Its design focuses on providing a way to declaratively specify a chain of these operators, transforming data as it moves from one end to the other. This requires thinking differently about intermediate state. Sometimes this leads to call sites that are more complex than one might expect â€“ especially when working with single values, errors, or data that needs to be shared. <code class="language-plaintext highlighter-rouge">async/await</code>â€™s <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md">Structured Concurrency</a> provides us with a new way to express this kind of logic. We can now write asynchronous code that is split into smaller pieces and reads from top-to-bottom instead of as a series of chained transforms.</p>

<p>Weâ€™re excited about the possibilities that <code class="language-plaintext highlighter-rouge">async/await</code> and <code class="language-plaintext highlighter-rouge">AsyncSequence</code> bring to the language. We believe this package will be a great place to explore future development and evolution of higher-level APIs in this space.</p>

<h2 id="whats-next">Whatâ€™s Next</h2>

<p>Today we are releasing a prototype version of the <strong>Swift Async Algorithms</strong> package. Our intent is to kickstart the project with a working implementation, then move forward with detailed design discussions on the Swift Forums. We welcome community involvement in:</p>

<ul>
  <li>Early adoption of the package and feedback on the design</li>
  <li>Implementation of the package</li>
  <li>Implementation of the tests</li>
  <li>Pitches and evolution for the future of the package</li>
</ul>

<p>We are using <a href="https://github.com/apple/swift-async-algorithms/issues">GitHub Issues</a> to track bugs, feature requests, and starter tasks.</p>
<h3 id="references">References</h3>

<h4 id="documentation">Documentation</h4>

<ul>
  <li><a href="https://developer.apple.com/documentation/combine/">Combine</a></li>
</ul>

<h4 id="related-proposals">Related Proposals</h4>

<ul>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md">Structured Concurrency</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md">Async / Await</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md">AsyncSequence</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0314-async-stream.md">AsyncStream</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0329-clock-instant-duration.md">Clock / Duration</a></li>
</ul>

<h4 id="companion-packages">Companion Packages</h4>

<ul>
  <li><a href="https://github.com/apple/swift-algorithms">Swift Algorithms</a></li>
  <li><a href="https://github.com/apple/swift-collections">Swift Collections</a></li>
</ul>
:ET