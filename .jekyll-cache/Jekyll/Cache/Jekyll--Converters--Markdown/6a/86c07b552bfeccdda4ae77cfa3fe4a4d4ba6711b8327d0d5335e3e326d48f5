I"66<p>Thread Sanitizer is now available on Linux as part of Swift 5.1! Head over to <a href="https://swift.org/download/#snapshots">Swift.org</a> and grab a Swift 5.1 Development snapshot to try it out.</p>

<p>The Swift language guarantees <a href="https://docs.swift.org/swift-book/LanguageGuide/MemorySafety.html">memory safety</a> in single threaded environments. However, conflicting accesses in multithreaded code lead to <em>data races</em>. Data races in Swift cause unexpected behavior and can even lead to memory corruption, breaking Swift’s memory safety. <a href="https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer">Thread Sanitizer</a> is a bug-finding tool that diagnoses data races at run time. It instruments code during compilation and detects data races when they happen during execution.</p>

<h3 id="example-of-a-data-race">Example of a Data Race</h3>

<p>Let’s take a look at a simple, multithreaded program. It uses <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/2016088-concurrentperform"><code class="language-plaintext highlighter-rouge">DispatchQueue.concurrentPerform</code></a> which implements an efficient <em>parallel for-loop</em>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Dispatch</span>

<span class="kd">func</span> <span class="nf">computePartialResult</span><span class="p">(</span><span class="nv">chunk</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Result</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="kt">Result</span><span class="p">()</span>
    <span class="c1">// Computing the result is an expensive operation.</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">results</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Result</span><span class="p">]()</span>

<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">concurrentPerform</span><span class="p">(</span><span class="nv">iterations</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span> <span class="n">index</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">r</span> <span class="o">=</span> <span class="nf">computePartialResult</span><span class="p">(</span><span class="nv">chunk</span><span class="p">:</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="s">"Result count: </span><span class="se">\(</span><span class="n">results</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>On first glance one might expect this program to print “Result count: 100”. Instead it may print “91”, “94”, or even crash. The reason is that the program contains a data race: multiple threads mutate the <code class="language-plaintext highlighter-rouge">results</code> array without synchronization.</p>

<p>In this example, it is easy to spot which part of the code introduces the data race. However, in real-world applications data races can be very difficult to diagnose. Their symptoms may be only observed sporadically, and they can change program behavior in subtle ways. In the worst case, they can corrupt memory and break Swift’s memory safety. Thankfully, Thread Sanitizer has proven to be an effective tool to detect and diagnose data races in Swift.</p>

<h3 id="using-thread-sanitizer">Using Thread Sanitizer</h3>

<p>To instrument your program with Thread Sanitizer, use the <code class="language-plaintext highlighter-rouge">-sanitize=thread</code> compiler flag and make sure to build your program in <em>Debug</em> mode. Thread Sanitizer relies on debug information to describe the problems it finds.</p>

<h4 id="swift-compiler">Swift Compiler</h4>

<p>Thread Sanitizer can be used from a Swift compiler invocation on the command line:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">swiftc -g -sanitize=thread
</span></code></pre></div></div>

<p>Because Thread Sanitizer currently works best with un-optimized code that is built with debug information, either omit compiler flags for optimization or use  <code class="language-plaintext highlighter-rouge">-Onone</code> to override a pre-existing optimization level.</p>

<h4 id="swift-package-manager">Swift Package Manager</h4>

<p>Thread Sanitizer can also be used directly with the Swift Package Manager:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">swift build -c debug --sanitize=thread
</span></code></pre></div></div>

<p>Use the <code class="language-plaintext highlighter-rouge">test</code> target (instead of <code class="language-plaintext highlighter-rouge">build</code>) to run your package’s tests with Thread Sanitizer enabled. Note that your tests need to actually exercise multithreaded code, otherwise Thread Sanitizer will not find data races.</p>

<h3 id="example">Example</h3>

<p>Let’s compile and run the simple example to see how Thread Sanitizer reports the data race. On Linux, Thread Sanitizer does not output unmangled Swift symbol names. You can use <code class="language-plaintext highlighter-rouge">swift-demangle</code> to make the report more clear:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">➤ swiftc main.swift -g -sanitize=thread -o race
</span><span class="gp">➤ ./race 2&gt;</span>&amp;1 | swift-demangle
<span class="go">==================
WARNING: ThreadSanitizer: Swift access race (pid=96)
  Modifying access of Swift variable at 0x7ffef26e65d0 by thread T2:
</span><span class="gp">    #</span>0 closure <span class="c">#1 (Swift.Int) -&gt; () in main main.swift:41 (swift-linux+0xb9921)</span>
<span class="gp">    #</span>1 partial apply forwarder <span class="k">for </span>closure <span class="c">#1 (Swift.Int) -&gt; () in main &lt;compiler-generated&gt;:? (swift-linux+0xb9d4c)</span>
<span class="go">       [... stack frames ...]

  Previous modifying access of Swift variable at 0x7ffef26e65d0 by thread T1:
</span><span class="gp">    #</span>0 closure <span class="c">#1 (Swift.Int) -&gt; () in main main.swift:41 (swift-linux+0xb9921)</span>
<span class="gp">    #</span>1 partial apply forwarder <span class="k">for </span>closure <span class="c">#1 (Swift.Int) -&gt; () in main race-b3c26c.o:? (swift-linux+0xb9d4c)</span>
<span class="go">       [... stack frames ...]

  Location is stack of main thread.

  Thread T2 (tid=99, running) created by main thread at:
</span><span class="gp">    #</span>0 pthread_create /home/buildnode/jenkins/workspace/oss-swift-5.1-package-linux-ubuntu-16_04/llvm/projects/compiler-rt/lib/tsan/rtl/tsan_interceptors.cc:980 <span class="o">(</span>swift-linux+0x487b5<span class="o">)</span>
<span class="go">       [... stack frames ...]
</span><span class="gp">    #</span>3 static Dispatch.DispatchQueue.concurrentPerform<span class="o">(</span>iterations: Swift.Int, execute: <span class="o">(</span>Swift.Int<span class="o">)</span> -&gt; <span class="o">())</span> -&gt; <span class="o">()</span> ??:? <span class="o">(</span>libswiftDispatch.so+0x1d916<span class="o">)</span>
<span class="gp">    #</span>4 __libc_start_main ??:? <span class="o">(</span>libc.so.6+0x2082f<span class="o">)</span>
<span class="go">
  Thread T1 (tid=98, running) created by main thread at:
</span><span class="gp">    #</span>0 pthread_create /home/buildnode/jenkins/workspace/oss-swift-5.1-package-linux-ubuntu-16_04/llvm/projects/compiler-rt/lib/tsan/rtl/tsan_interceptors.cc:980 <span class="o">(</span>swift-linux+0x487b5<span class="o">)</span>
<span class="go">       [...stack frames ...]
</span><span class="gp">    #</span>3 static Dispatch.DispatchQueue.concurrentPerform<span class="o">(</span>iterations: Swift.Int, execute: <span class="o">(</span>Swift.Int<span class="o">)</span> -&gt; <span class="o">())</span> -&gt; <span class="o">()</span> ??:? <span class="o">(</span>libswiftDispatch.so+0x1d916<span class="o">)</span>
<span class="gp">    #</span>4 __libc_start_main ??:? <span class="o">(</span>libc.so.6+0x2082f<span class="o">)</span>
<span class="go">
</span><span class="gp">SUMMARY: ThreadSanitizer: Swift access race main.swift:41 in closure #</span>1 <span class="o">(</span>Swift.Int<span class="o">)</span> -&gt; <span class="o">()</span> <span class="k">in </span>main
<span class="go">==================
[... more identical warnings ...]
==================
</span></code></pre></div></div>

<p>A good place to start for understanding Thread Sanitizer reports is the summary line.  It shows:</p>

<ul>
  <li>The type of bug detected, in this case a “Swift access race”</li>
  <li>The source location, main.swift:41, which is <code class="language-plaintext highlighter-rouge">results.append(r)</code></li>
  <li>The enclosing function, which in this case is a a compiler-generated closure</li>
</ul>

<p>Note that a data race involves at least two threads concurrently accessing the same memory location (without proper synchronization) where at least one of them writes. Thread Sanitizer reports which threads were involved (“Modifying access/Previous modifying access … by thread …”) and provides the stack traces of these two conflicting accesses.</p>

<p>In this simple example, both accesses were produced by the same source statement. However, this is not always the case. Knowing the traces for both accesses can be invaluable when debugging subtle interactions in large applications. The report also states how the racing threads were created (“Thread … created by …”). In this example, they were created by the main thread in a call to <code class="language-plaintext highlighter-rouge">concurrentPerform</code>.</p>

<p>Once an issue is understood, the next step is to fix it.  How this is done heavily depends on the specific situation and the goals of the code.  For example, the goal could be to use concurrency to prevent a long-running task from locking up the user interface of an app. A different goal could be to speed up a service by splitting up its workload into separate work items and process them in parallel to utilize more cores on a powerful server machine.</p>

<p>Even in the simple example, there are many different choices for fixing the data race. A general guideline is to prefer high-level abstractions over low-level synchronization primitives whenever the environment and performance constraints allow for it. Let’s use a serial queue to add proper synchronization to the example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">serialQueue</span> <span class="o">=</span> <span class="kt">DispatchQueue</span><span class="p">(</span><span class="nv">label</span><span class="p">:</span> <span class="s">"Results Queue"</span><span class="p">)</span>

<span class="kt">DispatchQueue</span><span class="o">.</span><span class="nf">concurrentPerform</span><span class="p">(</span><span class="nv">iterations</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span> <span class="n">index</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">r</span> <span class="o">=</span> <span class="nf">computePartialResult</span><span class="p">(</span><span class="nv">chunk</span><span class="p">:</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">serialQueue</span><span class="o">.</span><span class="n">sync</span> <span class="p">{</span>
        <span class="n">results</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above code establishes proper synchronization by serializing calls to <code class="language-plaintext highlighter-rouge">results.append</code>, which removes the data race. Note that the rest of the closure including <code class="language-plaintext highlighter-rouge">computePartialResult</code> still executes in parallel. This means that the order in which the partial results will appear in the <code class="language-plaintext highlighter-rouge">results</code> array may change between different runs of the program.</p>

<p>One of the main goals of Swift is to make programming simple things easy and difficult things possible. Writing efficient, multithreaded programs is one of those difficult things. Swift guarantees memory safety in the absence of data races, and allows developers to take on additional complexity when they need to. With Thread Sanitizer, developers have a tool in their tool belt that helps bring Swift’s safety and productivity to multithreaded environments.</p>

<h3 id="questions">Questions?</h3>

<p>Please feel free to post questions about this post on the <a href="https://forums.swift.org/t/swift-org-blog-thread-sanitizer-for-swift-on-linux/27872">associated thread</a> on the <a href="https://forums.swift.org">Swift forums</a>.</p>

:ET