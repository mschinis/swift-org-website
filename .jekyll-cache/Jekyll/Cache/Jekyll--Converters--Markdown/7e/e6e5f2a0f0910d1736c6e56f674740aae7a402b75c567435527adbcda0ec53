I"¾6<p>I am delighted to introduce a new open source project for the Swift Server ecosystem, <a href="https://github.com/apple/swift-nio-ssh">SwiftNIO SSH</a>. Distributed as a Swift package, SwiftNIO SSH is designed to enable Swift developers to interact with the SSH network protocol.</p>

<h2 id="what-is-swiftnio-ssh">What is SwiftNIO SSH?</h2>

<p>SwiftNIO SSH is a programmatic implementation of SSH: that is, it is a collection of APIs that allow programmers to implement SSH-speaking endpoints. Critically, this means it is more like libssh2 than openssh. SwiftNIO SSH does not ship production-ready SSH clients and servers, but instead provides the building blocks for building this kind of client and server.</p>

<p>There are a number of reasons to provide a programmatic SSH implementation. One is that SSH has a unique relationship to user interactivity. Technical users are highly accustomed to interacting with SSH interactively, either to run commands on remote machines or to run interactive shells. Having the ability to programmatically respond to these requests enables interesting alternative modes of interaction. As prior art, we can point to Twistedâ€™s <a href="https://howto.lintel.in/how-to-run-manhole-service-in-twisted/">Manhole</a>, which uses <a href="https://twistedmatrix.com/trac/wiki/TwistedConch">a programmatic SSH implementation called <code class="language-plaintext highlighter-rouge">conch</code></a> to provide an interactive Python interpreter within a running Python server, or <a href="https://github.com/shazow/ssh-chat">ssh-chat</a>, a SSH server that provides a chat room instead of regular SSH shell functionality. Innovative uses can also be imagined for TCP forwarding.</p>

<p>Another good reason to provide programmatic SSH is that it is not uncommon for services to need to interact with other services in a way that involves running commands. While <code class="language-plaintext highlighter-rouge">Process</code> solves this for the local use-case, sometimes the commands that need to be invoked are remote. While <code class="language-plaintext highlighter-rouge">Process</code> could launch an <code class="language-plaintext highlighter-rouge">ssh</code> client as a sub-process in order to run this invocation, it can be substantially more straightforward to simply invoke SSH directly. This is <a href="https://www.libssh2.org/"><code class="language-plaintext highlighter-rouge">libssh2</code></a>â€™s target use-case. SwiftNIO SSH provides the equivalent of the networking and cryptographic layer of libssh2, allowing motivated users to drive SSH sessions directly from within Swift services.</p>

<h2 id="what-does-swiftnio-ssh-support">What does SwiftNIO SSH support?</h2>

<p>SwiftNIO SSH supports SSHv2 with the following feature set:</p>

<ul>
  <li>All session channel features, including shell and exec channel requests</li>
  <li>Direct and reverse TCP port forwarding</li>
  <li>Modern cryptographic primitives only: Ed25519 and EDCSA over the major NIST curves (P256, P384, P521) for asymmetric cryptography, AES-GCM for symmetric cryptography, x25519 for key exchange</li>
  <li>Password and public key user authentication</li>
  <li>Supports all platforms supported by SwiftNIO and Swift Crypto</li>
</ul>

<h2 id="how-do-i-use-swiftnio-ssh">How do I use SwiftNIO SSH?</h2>

<p>SwiftNIO SSH provides a SwiftNIO <code class="language-plaintext highlighter-rouge">ChannelHandler</code>, <code class="language-plaintext highlighter-rouge">NIOSSHHandler</code>. This handler implements the bulk of the SSH protocol. Users are not expected to generate SSH messages directly: instead, they interact with the <code class="language-plaintext highlighter-rouge">NIOSSHHandler</code> through child channels and delegates.</p>

<p>SSH is a multiplexed protocol: each SSH connection is subdivided into multiple bidirectional communication channels called, appropriately enough, channels. SwiftNIO SSH reflects this construction by using a â€œchild channelâ€ abstraction. When a peer creates a new SSH channel, SwiftNIO SSH will create a new NIO <code class="language-plaintext highlighter-rouge">Channel</code> that is used to represent all traffic on that SSH channel. Within this child <code class="language-plaintext highlighter-rouge">Channel</code> all events are strictly ordered with respect to one another: however, events in different <code class="language-plaintext highlighter-rouge">Channel</code>s may be interleaved freely by the implementation.</p>

<p>An active SSH connection therefore looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â”Œ â”€ NIO Channel â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”

â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚                           â”‚
â”‚   â”‚                           â”‚   â”‚
    â”‚                           â”‚
â”‚   â”‚                           â”‚   â”‚
    â”‚       NIOSSHHandler       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚                           â”‚   â”‚                  â”‚
    â”‚                           â”‚                      â”‚
â”‚   â”‚                           â”‚   â”‚                  â”‚
    â”‚                           â”‚                      â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                  â”‚
                                                       â”‚
â”” â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”˜                  â”‚
                                                       â”‚
                                                       â”‚
                                                       â”‚
                                                       â”‚
                                                       â–¼
    â”Œâ”€â”€ SSH Child Channel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                                         â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”œâ”€â”€â”€â”
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”œâ”€â”€â”€â”
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚   â”‚
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚   â”‚
    â”‚   â”‚        User Handler       â”‚      â”‚        User Handler        â”‚     â”‚   â”‚   â”‚
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚   â”‚
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚   â”‚
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚   â”‚
    â”‚   â”‚                           â”‚      â”‚                            â”‚     â”‚   â”‚   â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚   â”‚   â”‚
    â”‚                                                                         â”‚   â”‚   â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
        â”‚                                                                         â”‚   â”‚
        â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚                                                                         â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div></div>

<p>An SSH channel is invoked with a channel type. SwiftNIO SSH supports three: <code class="language-plaintext highlighter-rouge">session</code>, <code class="language-plaintext highlighter-rouge">directTCPIP</code>, and <code class="language-plaintext highlighter-rouge">forwardedTCPIP</code>. The most common channel type is <code class="language-plaintext highlighter-rouge">session</code>, which is used to represent the invocation of a program, whether a specific named program or a shell. The other two channel types are related to TCP port forwarding, and will be discussed later.</p>

<p>An SSH channel operates on a single data type: <code class="language-plaintext highlighter-rouge">SSHChannelData</code>. This structure encapsulates the fact that SSH supports both regular and â€œextendedâ€ channel data. The regular channel data (<code class="language-plaintext highlighter-rouge">SSHChannelData.DataType.channel</code>) is used for the vast majority of core data. In <code class="language-plaintext highlighter-rouge">session</code> channels the <code class="language-plaintext highlighter-rouge">.channel</code> data type is used for standard input and standard output: the <code class="language-plaintext highlighter-rouge">.stdErr</code> data type is used for standard error. In TCP forwarding channels, the <code class="language-plaintext highlighter-rouge">.channel</code> data type is the only kind used, and represents the forwarded data.</p>

<h3 id="channel-events">Channel Events</h3>

<p>A <code class="language-plaintext highlighter-rouge">session</code> channel represents an invocation of a command. Exactly how the channel operates is communicated in a number of inbound user events. SwiftNIO SSH supports a wide range, and it covers the most important use-cases, including executing a command directly, requesting a shell, requesting a pseudo terminal, setting environment variables, and more.</p>

<h3 id="user-authentication">User Authentication</h3>

<p>User authentication is a vital part of SSH. SwiftNIO SSH manages user authentication via a series of delegate protocols. These protocols are fully asynchronous, supporting use-cases that may need to read from disk in order to perform user authentication.</p>

<h3 id="direct-port-forwarding">Direct Port Forwarding</h3>

<p>Direct port forwarding is port forwarding from client to server. In this mode traditionally the client will listen on a local port, and will forward inbound connections to the server. It will ask that the server forward these connections as outbound connections to a specific host and port.</p>

<p>These channels can be directly opened by clients by using the <code class="language-plaintext highlighter-rouge">.directTCPIP</code> channel type.</p>

<h3 id="remote-port-forwarding-and-global-requests">Remote Port Forwarding and Global Requests</h3>

<p>Remote port forwarding is a less-common situation where the client asks the server to listen on a specific address and port, and to forward all inbound connections to the client. As the client needs to request this behaviour, it does so using â€œglobal requestsâ€, an SSH feature that enables requesting features that operate at a connection-scope.</p>

<p>Global requests are initiated using <code class="language-plaintext highlighter-rouge">NIOSSHHandler.sendGlobalRequest</code>, and are received and handled by way of a <code class="language-plaintext highlighter-rouge">GlobalRequestDelegate</code>. There are two global requests supported today:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GlobalRequest.TCPForwardingRequest.listen(host:port:)</code>: a request for the server to listen on a given host and port.</li>
  <li><code class="language-plaintext highlighter-rouge">GlobalRequest.TCPForwardingRequest.cancel(host:port:)</code>: a request to cancel the listening on the given host and port.</li>
</ul>

<p>Servers may be notified of and respond to these requests using a <code class="language-plaintext highlighter-rouge">GlobalRequestDelegate</code>. This delegate will be invoked any time a global request is received. Once a listener is established, inbound connections are then sent from server to client using the <code class="language-plaintext highlighter-rouge">.forwardedTCPIP</code> channel type.</p>

<h2 id="additional-resources">Additional Resources</h2>

<p>Additional documentation and examples can be found on <a href="https://github.com/apple/swift-nio-ssh">GitHub</a>.</p>

<h2 id="project-status">Project Status</h2>

<p>This project is currently in a pre-release state. While itâ€™s considered to be feature complete, weâ€™d like to give it some more time to bake in the public eye before we tag a 1.0 release. However, we do not expect any API breakage between now and that release.</p>

<h2 id="getting-involved">Getting Involved</h2>

<p>If you are interested in SwiftNIO SSH, please get involved! SwiftNIO SSH is a fully open-source project, developed on <a href="https://github.com/apple/swift-nio-ssh">GitHub</a>. Contributions from the open source community are welcome at all times. We encourage discussion on the <a href="https://forums.swift.org/c/server">Swift forums</a>. For bug reports, feature requests, and pull requests, please use the GitHub repository.</p>

<p>Weâ€™re very excited to see what amazing things you do with SwiftNIO SSH!</p>
:ET