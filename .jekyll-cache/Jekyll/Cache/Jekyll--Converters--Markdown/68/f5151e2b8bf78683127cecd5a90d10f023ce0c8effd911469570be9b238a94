I"‘=<p>The development, refinement, and deployment of <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0200-raw-string-escaping.md">SE-0200 Enhancing String Literals Delimiters to Support Raw Text</a> was a long and surprising journey. It ended with a uniquely Swift take on ‚Äúraw strings‚Äù that focused on adding custom delimiters to string literals and escape sequences.</p>

<p>This post discusses what raw strings are, how Swift designed its take on this technology, and how you can use this new Swift 5 feature in your code.</p>

<h2 id="escape-sequences">Escape Sequences</h2>

<p>Escape sequences are backslash-prepended combinations like <code class="language-plaintext highlighter-rouge">\\</code>, <code class="language-plaintext highlighter-rouge">\"</code>, and <code class="language-plaintext highlighter-rouge">\u{n}</code> that incorporate characters that would otherwise be hard to express inside a normal string literal. Swift escape sequences include:</p>

<ul>
  <li>The special characters <code class="language-plaintext highlighter-rouge">\0</code> (null character), <code class="language-plaintext highlighter-rouge">\\</code> (backslash), <code class="language-plaintext highlighter-rouge">\t</code> (horizontal tab), <code class="language-plaintext highlighter-rouge">\n</code> (line feed), <code class="language-plaintext highlighter-rouge">\r</code> (carriage return), <code class="language-plaintext highlighter-rouge">\"</code> (double quotation mark) and <code class="language-plaintext highlighter-rouge">\'</code> (single quotation mark)</li>
  <li>Arbitrary Unicode scalars, written as <code class="language-plaintext highlighter-rouge">\u{n}</code>, where <em>n</em> is a 1‚Äì8 digit hexadecimal number with a value equal to a valid Unicode code point</li>
  <li>Interpolated expressions, introduced by <code class="language-plaintext highlighter-rouge">\(</code> and terminated by <code class="language-plaintext highlighter-rouge">)</code>. Swift‚Äôs interpolation feature offers a powerful and compiler-checked way to add content to strings. It is one of the language‚Äôs highlights.</li>
</ul>

<p>For example, the string literal <code class="language-plaintext highlighter-rouge">"hello\n\n\tworld"</code> consists of three lines, with ‚Äúhello‚Äù on the first and ‚Äúworld‚Äù on the third. ‚Äúworld‚Äù is indented by a single tab:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hello

	world
</code></pre></div></div>

<p>A raw string, in contrast, ignores escape sequences and treats all content as literal characters. In a raw string, <code class="language-plaintext highlighter-rouge">\n</code> represents the backslash character followed by the letter n rather than a line feed. This feature is used in applications that produce code output, that work with regular expressions, that use in-app source code (for example, when interactively teaching a language), and for pre-escaped domain-specific content like JSON and XML.</p>

<h2 id="raw-strings">Raw Strings</h2>

<p>Raw strings are used in many languages including C#, Perl, Rust, Python, Ruby,  and Scala. A raw string does not interpret escape sequences. Its content continues until it reaches the string‚Äôs end delimiter, which varies by language, as in the following table:</p>

<table>
  <thead>
    <tr>
      <th>Syntax</th>
      <th>Language(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">'Hello, world!'</code></td>
      <td>Bourne shell, Perl, PHP, Ruby, Windows PowerShell</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">q(Hello, world!)</code></td>
      <td><a href="https://en.wikipedia.org/wiki/String_literal">Perl</a> (alternate)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">%q(Hello, world!)</code></td>
      <td>Ruby (alternate)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">@"Hello, world!"</code></td>
      <td><a href="https://msdn.microsoft.com/en-us/library/69ze775t.aspx">C#</a>, F#</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">R"(Hello, world!)"</code></td>
      <td><a href="https://en.cppreference.com/w/cpp/language/string_literal">C++11</a></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">r"Hello, world!"</code></td>
      <td><a href="https://tour.dlang.org/tour/en/basics/alias-strings">D</a>, <a href="http://wiki.c2.com/?RawStrings">Python</a></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">r#"Hello, world!"#</code></td>
      <td><a href="https://doc.rust-lang.org/reference/tokens.html#raw-string-literals">Rust</a></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">"""hello \' world"""</code> and <code class="language-plaintext highlighter-rouge">raw"Hello, world!"</code></td>
      <td>Scala</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">`Hello, world!`</code></td>
      <td><a href="https://tour.dlang.org/tour/en/basics/alias-strings">D</a>, <a href="https://golang.org/ref/spec">Go</a>, `‚Ä¶`</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">``...``</code></td>
      <td><a href="http://openjdk.java.net/jeps/326">Java</a>, any number of `</td>
    </tr>
  </tbody>
</table>

<p>Most languages adopt a prefix (like <code class="language-plaintext highlighter-rouge">q</code>, <code class="language-plaintext highlighter-rouge">R</code>, or <code class="language-plaintext highlighter-rouge">r</code>) to indicate raw content. Rust and Java go beyond this to allow customizable delimiters. This feature allows variations of the delimiter to be included within the string, allowing more expressive raw string content.</p>

<h2 id="multi-line-swift-strings">Multi-Line Swift Strings</h2>

<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0168-multi-line-string-literals.md">SE-0168 Multi-Line String Literals</a> not only introduced a way to create string literals with more than one line and no new-line escapes, it also provided a hint of the direction the Swift language would take in terms of custom delimiters. Since multi-line strings used three quotes <code class="language-plaintext highlighter-rouge">"""</code> to start and end literals, they allowed individual quote marks and new lines without escape sequences. Under the new system, this literal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"\"Either it brings tears to their eyes, or else -\"\n\n\"Or else what?\" said Alice, for the Knight had made a sudden pause.\n\n\"Or else it doesn't, you know.\""
</code></pre></div></div>

<p>became this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"""
    "Either it brings tears to their eyes, or else -"
    
    "Or else what?" said Alice, for the Knight had made a sudden pause.

    "Or else it doesn't, you know."
    """
</code></pre></div></div>

<p>Quote and newline backslashes evaporate in the new syntax. The resulting string literal is clear, readable, and inspectable. In introducing the new delimiter and multi-line support, new-line and quote marks can be used without escapes, taking the first steps forward towards better literals.</p>

<p>Multi-line literals did not lose any of Swift‚Äôs string power. They support escapes, including interpolation, unicode character insertion, and so forth. At the same time, the feature set the standard for what Swift ‚Äúraw‚Äù strings should look like.</p>

<h2 id="swift-raw-strings-take-one">Swift Raw Strings: Take One</h2>

<p><a href="https://forums.swift.org/t/se-0200-raw-mode-string-literals/11048">SE-0200</a> first entered review in March 2018. Its <a href="https://github.com/apple/swift-evolution/blob/1f1bc5e969ee7ca3ad222b4a0f2fa7dad81394e7/proposals/0200-raw-string-escaping.md">initial design</a> added a single <code class="language-plaintext highlighter-rouge">r</code> prefix to single and multi-line strings. The community disliked the design (‚ÄúThe proposed <code class="language-plaintext highlighter-rouge">r"..."</code> syntax didn‚Äôt fit well with the rest of the language‚Äù) and felt it wasn‚Äôt expansive enough to support enough use-cases. The proposal was <a href="https://forums.swift.org/t/returned-for-revision-se-0200-raw-mode-string-literals/11630">returned for revision</a> in April 2018. It was time to search for a better design, better use-cases, and a more Swift-aligned expression.</p>

<p>Revisiting design involved an extensive review of raw strings in other languages, eventually focussing on Rust. Rust not only supports raw strings, it uses customizable delimiters. You can create raw strings with <code class="language-plaintext highlighter-rouge">r#""#</code>, <code class="language-plaintext highlighter-rouge">r##""##</code>, <code class="language-plaintext highlighter-rouge">r###""###</code>, and so forth. You choose the number of pound signs to pad each side of the string literal. In the unlikely circumstance you needed to include <code class="language-plaintext highlighter-rouge">"#</code> in a string, which would normally terminate a basic raw string, these custom delimiters ensure you can add a second pound sign, allowing you to adjust the way the string ends.</p>

<p>Yes, it is extremely rare you ever need more than one pound sign but Rust‚Äôs design takes that rarity into account. It creates an expansible and customizable system that offers coverage of even the most outlandish edge cases. That strength is impressive and core to Swift‚Äôs eventual design. In its revision, SE-0200 dropped the <code class="language-plaintext highlighter-rouge">r</code> (which stands for ‚Äúraw‚Äù) while adopting the adaptable Rust-style pound signs on each side of the literal. As in Rust, each Swift string literal must use the same number of pounds before and after, whether working with single- or multi-line strings.</p>

<p>At that point, inspiration struck as the SE-0200 team realized that custom delimiters offered more power than plain raw strings.</p>

<h2 id="customizable-delimiters">Customizable Delimiters</h2>

<p>When using the updated raw strings design, time and again the team regretted the loss of string interpolation. By definition, raw strings do not use escape sequences. Interpolation depends on them. It was SE-0200 co-author Brent Royal-Gordon who had the flash of insight that we could incorporate the Rust-inspired syntax while retaining access to escape sequences.</p>

<p>Instead of creating raw strings, SE-0200 introduced something similar: a blend of the alternate delimiters Swift first encountered in multi-line strings and the customizable delimiters from Rust. By extending that customization to escape sequences, SE-0200‚Äôs design inherited all the power of raw strings <em>and</em> the convenience of Swift interpolation.</p>

<p>SE-0200 adds custom delimiters at the start and end of each string literal and, in lockstep, customizes the escape sequence delimiter from a simple backslash to one decorated with pound-signs. This design matches escape sequences to the number of pound-signs for the string literal. For a <code class="language-plaintext highlighter-rouge">""</code> string, the escape token is <code class="language-plaintext highlighter-rouge">\</code>. For <code class="language-plaintext highlighter-rouge">#""#</code>, it is <code class="language-plaintext highlighter-rouge">\#</code>, and <code class="language-plaintext highlighter-rouge">##""##</code> it is <code class="language-plaintext highlighter-rouge">\##</code>, and so forth.</p>

<p>By adding escape sequences ‚Äì this modification supports all of them, not just interpolation ‚Äì Swift‚Äôs #-annotated strings were no longer ‚Äúraw‚Äù. They support the same features you find in raw strings, they mostly act like raw strings, however the design incorporates escaping, which means the literals are not raw. If you feel fanciful, you can call them ‚Äúmedium rare‚Äù strings.</p>

<p>Any time you include what would otherwise be recognized as an escape sequence, you can extend the number of delimiter pound-signs until the contents are no longer interpreted. It is rare to need this feature but when used, just one or two pound signs should both support interpolation in some parts of your string and disallow it in others:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"\(thisInterpolates)"
#"\(thisDoesntInterpolate) \#(thisInterpolates)"#
##"\(thisDoesntInterpolate) \#(thisDoesntInterpolate) \##(thisInterpolates)"##

"\n" // new line
#"\n"# // backslash plus n
#"\#n"# // new line
</code></pre></div></div>

<h2 id="adopting-se-0200-strings-in-your-code">Adopting SE-0200 Strings In Your Code</h2>

<p>In Swift 5, each of the following literals declares the string ‚ÄúHello‚Äù, even though they use a variety of single and multi-line styles:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let u = "Hello" // No pounds
let v = #"Hello"# // One pound
let w = ####"Hello"#### // Many pounds
let x = "\("Hello")" // Interpolation
let y = #"\#("Hello")"# // Interpolation with pound
let z = """ // Multiline
    Hello
    """
let a = #""" // Multiline with pound
    Hello
    """#
</code></pre></div></div>

<p>The rules are as follows:</p>

<ul>
  <li>Match the number of pound-signs before and after a string literal, from zero to however many. ‚ÄúZero‚Äù or ‚Äúone‚Äù are almost always the right answer for ‚Äúhowever many‚Äù.</li>
  <li>When using pound-signs, you change the escape sequence from a single backslash to a backslash infixed with the same number of pound signs. A <code class="language-plaintext highlighter-rouge">##"Hello"##</code>  string uses a <code class="language-plaintext highlighter-rouge">\##</code> escape sequence.</li>
  <li>Anything that doesn‚Äôt match the closing delimiter is part of the string. To add <code class="language-plaintext highlighter-rouge">"""</code> to a multiline string without escaping, change the delimiter by adding a pound-sign.</li>
  <li>Use the fewest pound signs required for the results you need. Zero is best. One is fine. Two or more should be very, very rare.</li>
</ul>

<p>With SE-0200, anyone writing code generation apps like PaintCode or Kite Compositor, writing network code with escaped-JSON, or including backslash-heavy ASCII clip art, can paste and go. Add pound-signs as needed, without sacrificing the convenience of string interpolation or escape sequences.</p>

<p>These delimiters ensure your code remains free of escape clutter. The results are cleaner. They‚Äôre easier to read and to cut/paste into your codebase. You‚Äôll be able to test, reconfigure, and adapt raw content without the hurdles of escaping and unescaping that otherwise limit your development.</p>

<p>Read more about Swift‚Äôs new custom string delimiters in the <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0200-raw-string-escaping.md">SE-0200 proposal</a>. It includes further details, many examples, and explores alternate designs that were considered and rejected.</p>

<h1 id="questions">Questions?</h1>

<p>Please feel free to post questions about this post on the <a href="https://forums.swift.org/t/swift-org-blog-behind-the-proposal-se-0200-enhancing-string-literals-delimiters-to-support-raw-text/20724">associated thread</a> on the <a href="https://forums.swift.org">Swift forums</a>.</p>

:ET