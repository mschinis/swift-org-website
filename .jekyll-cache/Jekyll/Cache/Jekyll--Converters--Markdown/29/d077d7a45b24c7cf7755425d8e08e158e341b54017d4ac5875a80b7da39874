I"<p>In Swift 4.1 the compiler now supports a new optimization mode which enables dedicated optimizations to reduce code size.</p>

<p>The Swift compiler comes with powerful optimizations. When compiling with <code class="language-plaintext highlighter-rouge">-O</code> the compiler tries to transform the code so that it executes with maximum performance. However, this improvement in runtime performance can sometimes come with a tradeoff of increased code size.
With the new <code class="language-plaintext highlighter-rouge">-Osize</code> optimization mode the user has the choice to compile for minimal code size rather than for maximum speed.</p>

<p>To enable the size optimization mode on the command line, use <code class="language-plaintext highlighter-rouge">-Osize</code> instead of <code class="language-plaintext highlighter-rouge">-O</code>. In Xcode 9.3 there is a new Swift compiler code generation build setting:</p>

<p><img src="https://swift.org/assets/images/osize-blog/Xcode-Osize-setting.png" alt="Xcode optimization mode settings" /></p>

<p>Also, the compilation mode — single file or whole-module — can now be selected independently of the optimization mode:</p>

<p><img src="https://swift.org/assets/images/osize-blog/Xcode-mode-setting.png" alt="Xcode compilation mode settings" /></p>

<p>The <code class="language-plaintext highlighter-rouge">-Osize</code> mode works in whole-module as well as in single-file compilation, whereas whole-module mode gives the best optimization results.</p>

<p>We have seen that using <code class="language-plaintext highlighter-rouge">-Osize</code> reduces code size from 5% to even 30% for some projects.</p>

<p>But what about performance? This completely depends on the project. For most applications the performance hit with <code class="language-plaintext highlighter-rouge">-Osize</code> will be negligible, i.e. below 5%. But for performance sensitive code <code class="language-plaintext highlighter-rouge">-O</code> might still be the better choice.</p>

<h3 id="impact-on-code-optimization">Impact on Code Optimization</h3>

<p>Let’s go into the details on what the compiler does differently with <code class="language-plaintext highlighter-rouge">-Osize</code>.
With <code class="language-plaintext highlighter-rouge">-Osize</code> the compiler optimizes the code, just like with <code class="language-plaintext highlighter-rouge">-O</code>.
But in contrast to <code class="language-plaintext highlighter-rouge">-O</code>, the compiler tries to avoid code duplication. For example, when inlining functions the compiler uses a lower size limit to decide whether a function should be inlined.</p>

<p>Completely disabling function inlining would be a bad idea, because inlining small functions often improve code size. For example consider simple getter functions, like</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">X</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">27</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The call overhead of calling this getter would be much higher than to inline the function. This is an extreme example, but it turns out that inlining is still worth up to a certain size while still improving code size.
In addition, function inlining can trigger other optimizations, which in turn can reduce code size. For example, in the code snippet below by inlining the getter <code class="language-plaintext highlighter-rouge">a.x</code> we know that <code class="language-plaintext highlighter-rouge">a.x</code> evaluates to 27 and hence the entire <code class="language-plaintext highlighter-rouge">if</code> branch can be optimized away:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">X</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">27</span> <span class="p">{</span>
        <span class="c1">// Can be optimized away if the getter of a.x is inlined</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Beside inlining, the compiler performs other code size specific optimizations with <code class="language-plaintext highlighter-rouge">-Osize</code>. For example, some code patterns for handling generic types or for Objective-C bridging are extracted into helper functions and are not generated inline.</p>

<h3 id="conclusion">Conclusion</h3>

<p>The new <code class="language-plaintext highlighter-rouge">-Osize</code> optimization mode is a great way to reduce code size for programs which are not super performance sensitive.</p>

<p>We like to encourage you to try <code class="language-plaintext highlighter-rouge">-Osize</code> and give us feedback. Share your experiences in the forum, using the <a href="https://forums.swift.org/tags/osize">osize</a> tag.</p>
:ET