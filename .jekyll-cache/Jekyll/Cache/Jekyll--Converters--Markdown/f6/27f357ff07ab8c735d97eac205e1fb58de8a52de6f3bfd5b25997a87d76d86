I"EF<p>Swift 5.4 is now officially released!  This release contains a variety of language and tooling improvements.</p>

<p>You can try out some of the new features in this <a href="https://github.com/twostraws/whats-new-in-swift-5-4">playground</a> put together by Paul Hudson.</p>

<p>An updated version of <a href="https://docs.swift.org/swift-book/">The Swift Programming Language</a> for Swift 5.4 is now available on Swift.org. It is also available for free on the <a href="https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11">Apple Books store</a>.</p>

<h3 id="language-updates">Language Updates</h3>

<p>Swift 5.4 includes the following new language features:</p>

<ul>
  <li>Support for multiple variadic parameters in functions, subscripts and initializers <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0284-multiple-variadic-parameters.md">(SE-0284)</a></li>
  <li>Extend implicit member syntax <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0287-implicit-member-chains.md">(SE-0287)</a></li>
  <li>Result builders <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md">(SE-0289)</a></li>
  <li>Local functions supporting overloading</li>
  <li>Property wrappers for local variables</li>
</ul>

<p>To prepare the way for a new concurrency model, the compiler now emits a warning and fix-it for unqualified uses of <code class="language-plaintext highlighter-rouge">await</code> as an identifier.  Those identifers will be interpreted as the keyword <code class="language-plaintext highlighter-rouge">await</code> in a future version of Swift as part of <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md">SE-0296</a>.</p>

<h3 id="runtime-performance-and-code-size-improvements">Runtime Performance and Code Size Improvements</h3>

<p>In Swift 5.4, protocol conformance checks at runtime are significantly faster, thanks to a faster hash table implementation for caching previous lookup results.  In particular, this speeds up common runtime <code class="language-plaintext highlighter-rouge">as?</code> and <code class="language-plaintext highlighter-rouge">as!</code> casting operations.</p>

<p>Further, consecutive array modifications now avoid redundant uniqueness checks.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="k">inout</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// Must do copy-on-write (CoW) check here.</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="c1">// The compiler no longer generates</span>
  <span class="c1">// a redundant CoW check here.</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, there are a variety of performance improvements:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String</code> interpolations are more aggressively constant-folded</li>
  <li>Fewer retain/release calls, especially for <code class="language-plaintext highlighter-rouge">inout</code> function arguments and within loops</li>
  <li>Generic metadata in the Standard Library is now <a href="https://forums.swift.org/t/generic-type-metadata-prespecialization/31659">specialized at compile time</a>, reducing dirty memory usage and improving performance</li>
</ul>

<h3 id="swift-package-manager-updates">Swift Package Manager Updates</h3>

<p>The Swift Package Manager has several important updates in Swift 5.4:</p>

<ul>
  <li>Swift packages that specify a 5.4 tools version can now explicitly declare targets as executable, which allows the use of the <code class="language-plaintext highlighter-rouge">@main</code> keyword in package code <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0294-package-executable-targets.md">(SE-0294)</a></li>
  <li>Swift Package Manager is now supported on Windows!</li>
  <li>Swift Package Manager caches package dependencies on a per-user basis, which reduces the amount of network traffic and increases performance of dependency resolution for subsequent uses of the same package</li>
  <li>Automatic test discovery is now the default on all platforms, removing the need in <code class="language-plaintext highlighter-rouge">LinuxMain.swift</code> (which has been deprecated)</li>
  <li>Multiple improvements to dependencies resolution infrastructure including in manifest loading and caching, leading to improved performance of dependency resolution</li>
  <li>Improved diagnostics infrastructure and error messages, leading to more actionable error messages for dependency resolutions issues and beyond</li>
</ul>

<h3 id="windows-platform-support">Windows Platform Support</h3>

<p>Support for Swift on Windows has progressed in several important ways:</p>

<ul>
  <li>Swift Package Manager now works on Windows</li>
  <li>The <code class="language-plaintext highlighter-rouge">WinSDK</code> module has been extended, covering a greater portion of the Windows developer SDK. This allows more of the APIs to be easily used for Windows applications without having to manually construct libraries to bridge the C interfaces to Swift</li>
  <li>Improvements to the installer should make using the toolchain with external tools easier by reducing the flags needed by default on Windows</li>
</ul>

<h2 id="developer-experience-improvements">Developer Experience Improvements</h2>

<h3 id="build-performance">Build Performance</h3>

<ul>
  <li>The Swift compiler is much better at tracking dependencies between files, resulting in a significant reduction in the number of files compiled for many kinds of changes during incremental builds</li>
  <li>Dependencies on member variables and functions of structs, enums, classes, and protocols are now tracked individually by the Swift compiler. This finer granularity speeds and shrinks rebuilds after changes to these entities</li>
  <li>Incremental builds produce deterministic products in many more cases</li>
</ul>

<h3 id="code-completion">Code Completion</h3>

<p>Code completion’s performance is now much faster within large function bodies.  In <a href="https://github.com/apple/swift-package-manager/blob/8c772339/Sources/Build/BuildPlan.swift#L1274">one example within the <code class="language-plaintext highlighter-rouge">swift-package-manager</code> repository</a>, code completion time for <code class="language-plaintext highlighter-rouge">self.</code> in Swift 5.4 is now 4 times faster (20ms → 5ms) than Swift 5.3, for repeated invocations in that file.</p>

<p>Code completion is also now more reliable in expressions that contain errors, and in expressions that are ambiguous without additional context.  For example, given:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>For the above code, code completion now has the following behavior:</p>

<ul>
  <li>Invoking code completion after <code class="language-plaintext highlighter-rouge">test().prefix(3).</code> suggests members of <code class="language-plaintext highlighter-rouge">String</code></li>
  <li>Invoking code completion after <code class="language-plaintext highlighter-rouge">test(a: 2).</code> suggests members of <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">String</code></li>
  <li>Invoking code completion after <code class="language-plaintext highlighter-rouge">$0.</code> in the following block suggests members of <code class="language-plaintext highlighter-rouge">Int</code>:<code class="language-plaintext highlighter-rouge">test { $0. }</code></li>
</ul>

<h3 id="type-checker">Type Checker</h3>

<p>Swift 5.4 improves type checking performance for “linked” expressions such as <code class="language-plaintext highlighter-rouge">a + b + (2 * c)</code>  For example, consider:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">S</span> <span class="p">{</span> <span class="k">var</span> <span class="nv">s</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="p">[</span><span class="kt">S</span><span class="p">])</span> <span class="p">{</span>
   <span class="n">_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
     <span class="p">(</span><span class="nv">$0</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$1</span><span class="o">.</span><span class="n">s</span> <span class="p">??</span> <span class="s">""</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$1</span><span class="o">.</span><span class="n">s</span> <span class="p">??</span> <span class="s">""</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$1</span><span class="o">.</span><span class="n">s</span> <span class="p">??</span> <span class="s">""</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For this code, the type checker completes in under 100 ms, where previously it would time out.</p>

<p>In addition, the type checker has improved performance for nested array literals that contain other literal expressions.  For example, the following invalid code would have previously produced a 
“too complex to solve in reasonable time” message from the compiler:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">E</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">first</span>
  <span class="k">case</span> <span class="n">second</span>
  <span class="k">case</span> <span class="n">third</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">dictionary</span> <span class="o">=</span> <span class="p">[</span>
  <span class="o">.</span><span class="nv">first</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
  <span class="o">.</span><span class="nv">second</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
  <span class="o">.</span><span class="nv">third</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span>
<span class="p">]</span>
</code></pre></div></div>

<p>The Swift 5.4 code now diagnoses this code as invalid with precise error messages:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: reference to member <span class="s1">'first'</span> cannot be resolved without a contextual <span class="nb">type</span>
.first : <span class="o">[</span> 0, 1, 2, 3, 4, 5, 6, 7],
 ^
error: reference to member <span class="s1">'second'</span> cannot be resolved without a contextual <span class="nb">type</span>
 .second : <span class="o">[</span> 8, 9, 10, 11, 12, 13, 14, 15],
 ^
error: reference to member <span class="s1">'third'</span> cannot be resolved without a contextual <span class="nb">type</span>
 .third : <span class="o">[</span>16, 17, 18, 19, 20, 21, 22, 23],
 ^
</code></pre></div></div>

<p>The type checker now has improved diagnostics for result builders, including invalid statements (e.g. invalid return statement), referencing invalid declarations, and pattern matching errors. For example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">condition</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Group</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">condition</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span>
          <span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">300</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For this code, the type checker will report the following error, along with a Fix-It to remove <code class="language-plaintext highlighter-rouge">return</code> to apply the result builder:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: cannot use explicit <span class="s1">'return'</span> statement <span class="k">in </span>the body of result builder <span class="s1">'SceneBuilder'</span>
 <span class="k">return </span>Text<span class="o">(</span><span class="s2">"Hello, World!"</span><span class="o">)</span>
 ^
</code></pre></div></div>

<h3 id="debugging">Debugging</h3>

<p>When debugging Swift code on Apple platforms, variables with resilient types (including Foundation value types such as <code class="language-plaintext highlighter-rouge">URL</code>, <code class="language-plaintext highlighter-rouge">URLComponents</code>, <code class="language-plaintext highlighter-rouge">Notification</code>, <code class="language-plaintext highlighter-rouge">IndexPath</code>, <code class="language-plaintext highlighter-rouge">Decimal</code>, <code class="language-plaintext highlighter-rouge">Data</code>, <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">Global</code>, <code class="language-plaintext highlighter-rouge">Measurement</code>, and <code class="language-plaintext highlighter-rouge">UUID</code>) are displayed in the Xcode variable view and the <code class="language-plaintext highlighter-rouge">frame variable</code> / <code class="language-plaintext highlighter-rouge">v</code> command again.</p>
:ET