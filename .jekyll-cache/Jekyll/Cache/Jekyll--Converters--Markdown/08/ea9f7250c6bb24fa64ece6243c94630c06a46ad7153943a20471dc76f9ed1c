I"ô<p>The Swift.org community makes use of the
<a href="https://github.com/apple/swift-lldb">LLDB debugger</a> to provide a
rich REPL as well as the debugging environment for the Swift Language.
Swift is tightly coupled to the version of the  Swift compiler embedded in the
debugger.  Tight integration of compiler and debugger enables accurate
inspection of Swift types as well as full-featured expression
evaluation in the context of a rapidly evolving language.</p>

<p>However, because of this tight integration, developers <em>must</em> use a
matched pair of compiler and debugger built using the same sources.
Debugging using any other version of LLDB can lead to unpredictable
results.</p>

<h3 id="why-combine-the-repl-and-debugger">Why Combine the REPL and Debugger?</h3>

<p>Several motivating factors contributed to the decision to use the
Swift debugger as a foundation for the Swift REPL.</p>

<ul>
  <li>
    <p><strong>Integrated debugging.</strong> The most obvious benefit is that the Swift
REPL is also a full-featured debugger. Itâ€™s trivial to declare a
function, set a breakpoint in it, and then call it.  When execution
stops at a breakpoint the full feature set of the debugger is
immediately available.</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1&gt; func answer() -&gt; Int {
  2.     return 42
  3. }
  4&gt; :b 2
  4&gt; answer()
Execution stopped at breakpoint.  Enter LLDB commands to investigate (type help for assistance.)
   1   	  func answer() -&gt; Int {
-&gt; 2   	      return 42
   3   	  }
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Recovering from failure.</strong> Fatal errors in Swift normally result in
immediate termination of a process, which makes sense for programmer
errors in production code but are undesirable in an interactive
context. The Swift REPL supports investigating failures with the full
debugger or unwinding for immediate recovery.</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1&gt; ["One", "Two"][2]
fatal error: Array index out of range
Execution interrupted. Enter Swift code to recover and continue.
Enter LLDB commands to investigate (type :help for assistance.)
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Robust expression evaluation.</strong> Supporting the full range of REPL
scenarios in the debugger set a high bar for the expression
evaluator.  As a result, expressions in the debugger have access to
the full range of language features in Swift and can freely declare
any valid language construct.</p>
  </li>
  <li>
    <p><strong>Consistent result formatting.</strong> The strategy used for textually
representing values in the REPL is shared by the debugger, ensuring
consistent output even for user-defined types.</p>
  </li>
</ul>

<h2 id="xcode-playground-support">Xcode Playground Support</h2>

<p>Swift developers can approach the language in many different ways. In
addition to the traditional command-line compiler and interactive REPL
one of the earliest experiences for many developers was through the
introduction of playgrounds in Xcode. Prior to Swift 3.0 and Xcode 8
this was only possible with the version of Swift included with Xcode.
The Xcode Playground Support project enables building a Swift toolchain
that includes everything necessary to integrate with the Xcode 8
playground experience. Playground Support will be included in
corresponding snapshots. Download a snapshot, install it, and select the
toolchain to work with the latest Swift features in Xcode playgrounds.</p>

<p>The project builds two frameworks:</p>

<ul>
  <li>
    <p><strong>PlaygroundSupport.</strong> This framework defines API that may be
explicitly referred to by playground code to communicate with Xcode. For
example: this is typical for playgrounds that identify a particular
view to display live for animation or interaction, and when playgrounds
automatically move between pages when defined criteria are met.</p>
  </li>
  <li>
    <p><strong>PlaygroundLogger.</strong> This project is used implicitly to record values
of interest on a line-by-line basis and communicate them to Xcode. Calls
are automatically injected into playground code so no explicit reference
is required.</p>
  </li>
</ul>

:ET