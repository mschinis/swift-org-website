<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Swift.org - Project Ideas</title>
  <meta name="author" content="Apple Inc." />
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <link rel="license" href="/LICENSE.txt" />
  <link rel="stylesheet" media="all" href="https://swift.org/assets/stylesheets/application.css" />
  <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="https://swift.org/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
  <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" />
  

  
  <link rel="canonical" href="https://swift.org/project-ideas/" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@SwiftLang" />
  
  <meta name="twitter:title" content="Swift.org" />
  <meta name="twitter:description" content="Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns." />
  

  <meta property="og:site_name" content="Swift.org" />
  <meta property="og:image" content="https://swift.org/apple-touch-icon-180x180.png" />
  
  
  <meta property="og:title" content="Swift.org" />
  <meta property="og:url" content="https://swift.org" />
  <meta property="og:description" content="Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns." />
  
</head>

<body>
<script src="https://swift.org/assets/javascripts/color-scheme-toggle.js"></script>
<nav role="navigation">
  <div class="nav-menu-container">
    <header class="menu-item logo-container" role="banner">
      <h1 id="logo">
        <a href="/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>
    <div id="menu-toggle" class="menu-item menu-toggle open"></div>
  </div>

  <div class="list-items">
    
    
    <ul>
      
      
      <li>
      
        <a href="/about/">About Swift</a>
        
      </li>
      
      
      <li>
      
        <a href="/blog/">Blog</a>
        
      </li>
      
      
      <li>
      
        <a href="/getting-started/">Getting Started</a>
        
      </li>
      
      
      <li>
      
        <a href="/download/">Download</a>
        
      </li>
      
      
      <li>
      
        <a href="/platform-support/">Platform Support</a>
        
      </li>
      
      
      <li>
      
        <a href="/documentation/">Documentation</a>
        
      </li>
      
    </ul>
    
    
    <h2>Community</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/community/">Community Overview</a>
        
      </li>
      
      
      <li>
      
        <a href="/diversity/">Diversity</a>
        
      </li>
      
      
      <li>
      
        <a href="/mentorship/">Mentorship</a>
        
      </li>
      
      
      <li>
      
        <a href="/contributing/">Contributing</a>
        
      </li>
      
      
      <li>
      
        <a href="/code-of-conduct/">Code of Conduct</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Development</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/source-code/">Source Code</a>
        
      </li>
      
      
      <li>
      
        <a href="/continuous-integration/">Continuous Integration</a>
        
      </li>
      
      
      <li>
      
        <a href="/source-compatibility/">Source Compatibility</a>
        
      </li>
      
      
      <li>
      
        <a href="/support/security.html">Security</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Efforts</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/swift-compiler/">Swift Compiler</a>
        
      </li>
      
      
      <li>
      
        <a href="/standard-library/">Standard Library</a>
        
      </li>
      
      
      <li>
      
        <a href="/package-manager/">Package Manager</a>
        
      </li>
      
      
      <li>
      
        <a href="/core-libraries/">Core Libraries</a>
        
      </li>
      
      
      <li>
      
        <a href="/lldb/">REPL, Debugger & Playgrounds</a>
        
      </li>
      
      
      <li>
      
        <a href="/server/">Swift on Server</a>
        
      </li>
      
      
      <li>
      
        <a href="/website/">Swift.org website</a>
        
      </li>
      
    </ul>
    
  </div>
</nav>

<main role="main">
  <article class="page">
  <header>
    <h1>Project Ideas</h1>
  </header>

  <p>This page contains a list of potential project ideas that we are keen to develop during GSoC 2018. If you would like to apply as a GSoC student, please follow these two steps to get started:</p>

<ol>
  <li>Read through this page and identify the project ideas you find interesting.</li>
  <li>Check out the <a href="https://forums.swift.org/c/development">Development forum</a> to connect with potential mentors.</li>
</ol>

<h2 id="potential-projects">Potential Projects</h2>

<h3 id="fuzzingstress-testing-tool">Fuzzing/stress-testing tool</h3>

<p><strong>Description</strong></p>

<p>Build a tool, in Swift code, which uses libSyntax to parse/mutate Swift projects for possible problems related to parser, type-checker, SIL generation, code-completion, refactoring actions, and sourcekitdâ€™s cursor-info functionality. The goal of the project is to stress-test the compiler pipeline and sourcekitd and catch crashers or hangs with mutations leading to invalid code, and invoking functionality like code-completion and refactoring at random points.</p>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>Testing and improvements to the robustness of the compiler pipeline and sourcekitd infrastructure.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>Swift (familiar)</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Nathan Hawes</p>

<p><strong>Expected difficulty</strong></p>

<p>Medium</p>

<h3 id="libsyntax-based-indentation-mechanism">libSyntax-based indentation mechanism</h3>

<p><strong>Description</strong></p>

<p>Replace existing Swift indentation mechanism with a new mechanism based on using libSyntax. Also part of this project will be to address the cases where the existing indentation results are sub-par.</p>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>A more robust and easier to maintain Swift indentation mechanism, along with improved indentation results.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>C++</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Xi Ge</p>

<p><strong>Expected difficulty</strong></p>

<p>Medium</p>

<h3 id="swift-compiler-integration-with-external-tools">Swift compiler integration with external tools</h3>

<p><strong>Description</strong></p>

<p>Add a compiler option that provides the path to an external tool for the compiler to execute and communicate with. The communication could be done via stdin/stdout using a JSON format. The compiler should pass the compiler arguments and the libSyntax tree of the currently compiling source file, allowing the tool to return custom diagnostics that the compiler includes along with the rest of the compiler diagnostics.</p>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>A convenient mechanism for development and integration of custom linters, formatters, or other tools, during a build operation.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>C++</li>
  <li>Swift (familiar)</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Rintaro Ishizaki</p>

<p><strong>Expected difficulty</strong></p>

<p>Easy</p>

<h3 id="integration-of-libsyntax-with-the-rest-of-the-compiler-pipeline">Integration of libSyntax with the rest of the compiler pipeline.</h3>

<p><strong>Description</strong></p>

<p>This project is for integrating the libSyntax tree and making use of it across the rest of the compiler pipeline (typechecker, diagnostics, etc.). It would involve:</p>
<ul>
  <li>Having the parser generate only a libSyntax tree</li>
  <li>Derive the AST nodes from the libSyntax tree and have the AST nodes point to libSyntax nodes for source information</li>
  <li>It should be possible to provide a serialized libSyntax tree to the compiler and have typechecking and code-generation functionality without needing to parse code.</li>
</ul>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>A robust architecture with a clean separation of the parsing functionality from the rest of the compiler pipeline, and enabling future work for implementing incremental re-parsing.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>C++</li>
  <li>Compiler-pipeline Basics</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Rintaro Ishizaki</p>

<p><strong>Expected difficulty</strong></p>

<p>Hard</p>

<h3 id="swiftpm-autogenerate-linuxmainswift-file-for-linux">SwiftPM: Autogenerate <code class="language-plaintext highlighter-rouge">LinuxMain.swift</code> file for Linux</h3>

<p><strong>Description</strong></p>

<p>Swift package authors are required to list their test cases in
a <code class="language-plaintext highlighter-rouge">LinuxMain.swift</code> file to run tests on Linux. This is because, it is not
possible (yet) to get a list of methods at runtime on Linux. However, we can use
<code class="language-plaintext highlighter-rouge">SourceKit</code> to find the test methods and then autogenerate this file as part of
the build process.</p>

<p>This project will involve:</p>
<ul>
  <li>Add a feature in SwiftPM to generate compiler arguments for <code class="language-plaintext highlighter-rouge">SourceKit</code>.</li>
  <li>Write (minimal) Swift bindings for SourceKitâ€™s C API.</li>
  <li>Write a tool that will use <code class="language-plaintext highlighter-rouge">SourceKit</code> to generate the <code class="language-plaintext highlighter-rouge">LinuxMain.swift</code> file.</li>
  <li>Integrate the above tool as part of the SwiftPM build process.</li>
</ul>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p><code class="language-plaintext highlighter-rouge">LinuxMain.swift</code> file is auto-generated on Linux as part of SwiftPM build process.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>Swift</li>
  <li>C/C++</li>
  <li>Build process knowledge will be helpful but not required.</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Ankit Aggarwal</p>

<p><strong>Expected difficulty</strong></p>

<p>Medium</p>

<h3 id="swiftpm-build-a-tool-to-suggest-the-next-semver-tag-of-a-package">SwiftPM: Build a tool to suggest the next semver tag of a package.</h3>

<p><strong>Description</strong></p>

<p>SwiftPM follows <a href="https://semver.org/">semver</a> for dependency management. It is
easily possible for a package author to release a new version that violates the
semver conventions. A tool that can suggest the next version of a package will
be incredibly useful for package developers. This can be done by comparing
public API of the last released version and the current state of the API.
<code class="language-plaintext highlighter-rouge">SourceKit</code> provides an option to generate module interface of a Swift module. We
should be able to leverage that to build this tool. It is possible that new
functionality needs to be added to <code class="language-plaintext highlighter-rouge">SourceKit</code>.</p>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>SwiftPM should have a command to will suggest the next semver tag. E.g.:</p>

<p>$ swift package next-version â€“after 1.4.3
Next tag should be 2.0.0 because of the following API changes:</p>
<ul>
  <li>public func foo() -&gt; Int</li>
  <li>public func foo() -&gt; String</li>
</ul>

<p><strong>Skills required</strong></p>

<ul>
  <li>Swift</li>
  <li>C/C++</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Ankit Aggarwal</p>

<p><strong>Expected difficulty</strong></p>

<p>Hard</p>

<h3 id="swiftpm-improve-command-line-status-reporting">SwiftPM: Improve command line status reporting</h3>

<p><strong>Description</strong></p>

<p>SwiftPM is a set of command line utilities that perform several interesting
tasks, e.g. dependency resolution, compiling, testing. The progress/status of
these tasks is reported in a mundane and serial fashion. Improving status
reporting using terminal based animations (and maybe emojis!) will lead to
a delightful experience for a package developer. As an example, see how buck
reports compilation progress: https://buckbuild.com/static/buck-build-15fps.gif</p>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>swift package resolve, swift build and swift test should have improved CLI output.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>Swift</li>
  <li>Terminal/Shell</li>
</ul>

<p><strong>Potential mentors</strong></p>

<p>Ankit Aggarwal</p>

<p><strong>Expected difficulty</strong></p>

<p>Medium</p>

<h3 id="swiftpm-mechanically-edit-packageswift-manifest-file">SwiftPM: Mechanically edit <code class="language-plaintext highlighter-rouge">Package.swift</code> manifest file</h3>

<p><strong>Description</strong>:</p>

<p>A Swift package uses a <code class="language-plaintext highlighter-rouge">Package.swift</code> manifest file to declare the package
specifications. This file should be manually edited in order to modify
dependencies, targets, products, etc. It would be really nice if package
developers can perform these operations using CLI. For e.g., adding a new target
requires creating a new directory, a source file and an entry in
<code class="language-plaintext highlighter-rouge">Package.swift</code>. If we can edit the manifest file mechanically, we can automate
such operations and make the process much easier. This would require using
<code class="language-plaintext highlighter-rouge">SourceKit</code> to figure out the cursor positions where the new entries should be
inserted in <code class="language-plaintext highlighter-rouge">Package.swift</code>.</p>

<p><strong>Expected outcomes/benefits/deliverables</strong></p>

<p>SwiftPM has ability to mechanically edit the <code class="language-plaintext highlighter-rouge">Package.swift</code> manifest file.</p>

<p><strong>Skills required</strong></p>

<ul>
  <li>Swift</li>
  <li>C/C++</li>
</ul>

<p><strong>Potential mentors</strong></p>

<ul>
  <li>Ankit Aggarwal</li>
</ul>

<p><strong>Expected difficulty</strong></p>

<p>Hard</p>

</article>

</main>

<footer role="contentinfo">
  <div class="footer-content">
    
    <p class="copyright">Copyright Â© 2022 Apple Inc. All rights reserved.</p>
    <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
    <p class="privacy">
      <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
      <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
    </p>
  </div>
  <div class="footer-other">
    <form
      class="color-scheme-toggle"
      role="radiogroup"
      tabindex="0"
      id="color-scheme-toggle"
    >
      <legend class="visuallyhidden">Color scheme preference</legend>
      <label for="scheme-light">
        <input id="scheme-light" type="radio" name="color-scheme-preference" value="light">
        <span class="color-scheme-toggle-label">Light</span>
      </label>
      <label for="scheme-dark">
        <input id="scheme-dark" type="radio" name="color-scheme-preference" value="dark">
        <span class="color-scheme-toggle-label">Dark</span>
      </label>
      <label for="scheme-auto" id="scheme-auto-wrapper">
        <input id="scheme-auto" type="radio" name="color-scheme-preference" value="auto">
        <span class="color-scheme-toggle-label">Auto</span>
      </label>
    </form>
    <aside>
      <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter"></i></a>
      <a href="/atom.xml" title="Subscribe to Site Updates"><i class="feed"></i></a>
    </aside>
  </div>
</footer>


<script src="https://swift.org/assets/javascripts/application.js"></script>
<!-- metrics -->
<script>
    /* RSID: */
    var s_account="awdswiftorg"
</script>
<script src="https://developer.apple.com/assets/metrics/scripts/analytics.js"></script>
<script>
    s.pageName= AC && AC.Tracking && AC.Tracking.pageName();

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)
</script>
<!-- /metrics -->
</body>
</html>
