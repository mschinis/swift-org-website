<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Swift.org - Reimplementation of Implicitly Unwrapped Optionals</title>
  <meta name="author" content="Apple Inc." />
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <link rel="license" href="/LICENSE.txt" />
  <link rel="stylesheet" media="all" href="/assets/stylesheets/application.css" />
  <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
  <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" />
  

  
  <link rel="canonical" href="https://swift.org/blog/iuo/" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@SwiftLang" />
  
  <meta name="twitter:title" content="Reimplementation of Implicitly Unwrapped Optionals" />
  <meta name="twitter:description" content="A new implementation of implicitly unwrapped optionals (IUOs) landed in the Swift compiler earlier this year and is available to try in recent Swift snapshots.
This completes the implementation of SE-0054 - Abolish ImplicitlyUnwrappedOptional Type.
This is an important change to the language that eliminated some inconsistencies in type checking and clarified the rule of how these values are to be treated so that it is consistent and easy to reason about. For more information, see the motivation section of that proposal.
" />
  

  <meta property="og:site_name" content="Swift.org" />
  <meta property="og:image" content="https://swift.org/apple-touch-icon-180x180.png" />
  
  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Reimplementation of Implicitly Unwrapped Optionals" />
  <meta property="og:url" content="https://swift.org/blog/iuo/" />
  <meta property="og:description" content="A new implementation of implicitly unwrapped optionals (IUOs) landed in the Swift compiler earlier this year and is available to try in recent Swift snapshots.
This completes the implementation of SE-0054 - Abolish ImplicitlyUnwrappedOptional Type.
This is an important change to the language that eliminated some inconsistencies in type checking and clarified the rule of how these values are to be treated so that it is consistent and easy to reason about. For more information, see the motivation section of that proposal.
" />
  <meta property="article:published_time" content="2018-04-26T05:00:00-04:00" />
  <meta property="article:modified_time" content="2022-06-14T07:17:09-04:00" />
  
</head>

<body>
<script src="/assets/javascripts/color-scheme-toggle.js"></script>
<nav role="navigation">
  <div class="nav-menu-container">
    <header class="menu-item logo-container" role="banner">
      <h1 id="logo">
        <a href="/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>
    <div id="menu-toggle" class="menu-item menu-toggle open"></div>
  </div>

  <div class="list-items">
    
    
    <ul>
      
      
      <li>
      
        <a href="/about/">About Swift</a>
        
      </li>
      
      
      <li>
      
        <a href="/blog/">Blog</a>
        
      </li>
      
      
      <li>
      
        <a href="/getting-started/">Getting Started</a>
        
      </li>
      
      
      <li>
      
        <a href="/download/">Download</a>
        
      </li>
      
      
      <li>
      
        <a href="/platform-support/">Platform Support</a>
        
      </li>
      
      
      <li>
      
        <a href="/documentation/">Documentation</a>
        
      </li>
      
    </ul>
    
    
    <h2>Community</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/community/">Community Overview</a>
        
      </li>
      
      
      <li>
      
        <a href="/diversity/">Diversity</a>
        
      </li>
      
      
      <li>
      
        <a href="/mentorship/">Mentorship</a>
        
      </li>
      
      
      <li>
      
        <a href="/contributing/">Contributing</a>
        
      </li>
      
      
      <li>
      
        <a href="/code-of-conduct/">Code of Conduct</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Development</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/source-code/">Source Code</a>
        
      </li>
      
      
      <li>
      
        <a href="/continuous-integration/">Continuous Integration</a>
        
      </li>
      
      
      <li>
      
        <a href="/source-compatibility/">Source Compatibility</a>
        
      </li>
      
      
      <li>
      
        <a href="/support/security.html">Security</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Efforts</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/swift-compiler/">Swift Compiler</a>
        
      </li>
      
      
      <li>
      
        <a href="/standard-library/">Standard Library</a>
        
      </li>
      
      
      <li>
      
        <a href="/package-manager/">Package Manager</a>
        
      </li>
      
      
      <li>
      
        <a href="/core-libraries/">Core Libraries</a>
        
      </li>
      
      
      <li>
      
        <a href="/lldb/">REPL, Debugger & Playgrounds</a>
        
      </li>
      
      
      <li>
      
        <a href="/server/">Swift on Server</a>
        
      </li>
      
      
      <li>
      
        <a href="/website/">Swift.org website</a>
        
      </li>
      
    </ul>
    
  </div>
</nav>

<main role="main">
<article class="post">
  <header>
    <h1>Reimplementation of Implicitly Unwrapped Optionals</h1>

    <time pubdate datetime="2018-04-26T05:00:00-04:00">April 26, 2018</time>
    
    
    
      <div class="byline">
        

        <span class="author">
          
            <a href="https://github.com/rudkx/" rel="nofollow" title="Mark Lacey (@rudkx) on GitHub">Mark Lacey</a>
          
        </span>
      </div>
      
    
    
  </header>

  <p>A new implementation of implicitly unwrapped optionals (IUOs) landed in the Swift compiler earlier this year and is available to try in recent Swift <a href="https://swift.org/download/#snapshots">snapshots</a>.
This completes the implementation of <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md">SE-0054 - Abolish ImplicitlyUnwrappedOptional Type</a>.
This is an important change to the language that eliminated some inconsistencies in type checking and clarified the rule of how these values are to be treated so that it is consistent and easy to reason about. For more information, see the <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md#motivation">motivation section</a> of that proposal.</p>

<p>The main change you’ll see is that diagnostics will now print <code class="language-plaintext highlighter-rouge">T?</code> rather than <code class="language-plaintext highlighter-rouge">T!</code> when referring to a value that was declared as an implicitly unwrapped optional with underlying type <code class="language-plaintext highlighter-rouge">T</code>.
You may also encounter a source compatibility issue that requires you to modify your code before it will compile successfully.</p>

<h2 id="implicit-unwrapping-is-part-of-a-declaration">Implicit Unwrapping is Part of a Declaration</h2>

<p><em>Implicitly unwrapped optionals</em> are optionals that are automatically unwrapped if needed for an expression to compile. To declare an optional that’s implicitly unwrapped, place a <code class="language-plaintext highlighter-rouge">!</code> after the type name rather than a <code class="language-plaintext highlighter-rouge">?</code>.</p>

<p>A mental model many people have for implicitly unwrapped optionals is that they are a type, distinct from regular optionals. In Swift 3, that was exactly how they worked: declarations like <code class="language-plaintext highlighter-rouge">var a: Int?</code> would result in <code class="language-plaintext highlighter-rouge">a</code> having type <code class="language-plaintext highlighter-rouge">Optional&lt;Int&gt;</code>, and declarations like <code class="language-plaintext highlighter-rouge">var b: String!</code> would result in <code class="language-plaintext highlighter-rouge">b</code> having type <code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional&lt;String&gt;</code>.</p>

<p>The new mental model for IUOs is one where you consider <code class="language-plaintext highlighter-rouge">!</code> to be a synonym for <code class="language-plaintext highlighter-rouge">?</code> with the addition that it adds a flag on the declaration letting the compiler know that the declared value can be implicitly unwrapped.</p>

<p>In other words, you can read <code class="language-plaintext highlighter-rouge">String!</code> as “this value has the type <code class="language-plaintext highlighter-rouge">Optional&lt;String&gt;</code> and also carries information saying that it can be implicitly unwrapped if needed”.</p>

<p>This mental model matches the new implementation. Everywhere you have <code class="language-plaintext highlighter-rouge">T!</code>, the compiler now treats it as having type <code class="language-plaintext highlighter-rouge">T?</code> , and adds a flag in its internal representation of the declaration to let the type checker know it can implicitly unwrap the value where necessary.</p>

<p>The most visible result of this change is that you’ll now see diagnostics talking about <code class="language-plaintext highlighter-rouge">T?</code> rather than <code class="language-plaintext highlighter-rouge">T!</code> for values declared with <code class="language-plaintext highlighter-rouge">T!</code>. Seeing <code class="language-plaintext highlighter-rouge">T?</code> in the diagnostic rather than <code class="language-plaintext highlighter-rouge">T!</code> takes a little getting used to, but embracing this new mental model should help you along.</p>

<h2 id="source-compatibility">Source Compatibility</h2>

<p>Most projects should build without running into compatibility issues. However, it’s possible that these implementation changes will result in changes in behavior that are consistent with SE-0054 but inconsistent with previous releases of the compiler.</p>

<h3 id="coercions-to-t">Coercions to T!</h3>

<p>Coercions of the form <code class="language-plaintext highlighter-rouge">as T!</code> were disallowed by SE-0054.</p>

<p>In Swift 4.1, there’s a deprecation warning for these coercions. In many cases, replacing <code class="language-plaintext highlighter-rouge">as T!</code> with <code class="language-plaintext highlighter-rouge">as T?</code>, or simply removing the coercion, results in successful compilation.</p>

<p>There are enough cases where existing code failed to compile using one of those two changes that there is special-case handling for this in the new implementation. Specifically, if you write <code class="language-plaintext highlighter-rouge">x as T!</code>, the compiler will first attempt to type check this as <code class="language-plaintext highlighter-rouge">x as T?</code>. Only if that fails, the compiler will attempt to type check it as <code class="language-plaintext highlighter-rouge">(x as T?)!</code>, forcing the optional.</p>

<p>This form of coercion is still considered deprecated, though, and this special handling may be removed in a future version of Swift.</p>

<h3 id="using--on-types-rather-than-declarations">Using ! on Types Rather Than Declarations</h3>

<p>Coercions to <code class="language-plaintext highlighter-rouge">T!</code> are a special case of a more general issue: using <code class="language-plaintext highlighter-rouge">!</code> as part of a type.</p>

<p>There are three places where using <code class="language-plaintext highlighter-rouge">!</code> as part of a type is permitted:</p>

<ol>
  <li>Property declarations</li>
  <li><em>Parameters</em> in function declarations</li>
  <li><em>Return values</em> in function declarations</li>
</ol>

<p>In other locations, <code class="language-plaintext highlighter-rouge">!</code> should be flagged as an error, and releases prior to Swift 4.1 attempted to do so, but missed some cases:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">fn</span><span class="p">:</span> <span class="p">(</span><span class="kt">Int</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="o">!</span> <span class="o">=</span> <span class="o">...</span>   <span class="c1">// error: not a function declaration!</span>
</code></pre></div></div>

<p>Swift 4.1 emits deprecation warnings in these scenarios but continues to honor the implicit-unwrapping behavior. The new implementation in recent snapshots treats the <code class="language-plaintext highlighter-rouge">!</code> as if it were <code class="language-plaintext highlighter-rouge">?</code> and emits a diagnostic telling you what’s happening and that using <code class="language-plaintext highlighter-rouge">!</code> in these locations is deprecated.</p>

<h3 id="calling-map-on-a-value-declared-as-an-implicitly-unwrapped-optional">Calling map on a Value Declared as an Implicitly Unwrapped Optional</h3>

<p>Previously code like this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">C</span> <span class="p">{}</span>
<span class="k">let</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Any</span><span class="p">]</span><span class="o">!</span> <span class="o">=</span> <span class="p">[</span><span class="kt">C</span><span class="p">()]</span>
<span class="k">let</span> <span class="nv">transformed</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="k">as!</span> <span class="kt">C</span> <span class="p">}</span>
</code></pre></div></div>

<p>would have resulted in force-unwrapping <code class="language-plaintext highlighter-rouge">values</code> and then calling <a href="https://developer.apple.com/documentation/swift/array/2908681-map"><code class="language-plaintext highlighter-rouge">map(_:)</code></a> on the array. This was true even if you had defined a member <code class="language-plaintext highlighter-rouge">map(_:)</code> in an extension of <code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional</code>, because member-lookup into <code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional</code> did not work as expected.</p>

<p>In the new implementation, because <code class="language-plaintext highlighter-rouge">!</code> is a synonym for <code class="language-plaintext highlighter-rouge">?</code>, the compiler attempts to call <a href="https://developer.apple.com/documentation/swift/optional/1539476-map"><code class="language-plaintext highlighter-rouge">map(_:)</code></a> on <code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code> here:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">transformed</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="k">as!</span> <span class="kt">C</span> <span class="p">}</span> <span class="c1">// calls Optional.map; $0 has type [Any]</span>
</code></pre></div></div>

<p>and produces: <code class="language-plaintext highlighter-rouge">warning: cast from '[Any]' to unrelated type 'C' always fails</code></p>

<p>Because this technically passes type checking, we won’t attempt to force-unwrap <code class="language-plaintext highlighter-rouge">values</code>.</p>

<p>You can work around this by using optional chaining to produce an optional array:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">transformed</span> <span class="o">=</span> <span class="n">values</span><span class="p">?</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="k">as!</span> <span class="kt">C</span> <span class="p">}</span> <span class="c1">// transformed has type Optional&lt;[C]&gt;</span>
</code></pre></div></div>

<p>or by force-unwrapping <code class="language-plaintext highlighter-rouge">values</code> to produce an array:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">transformed</span> <span class="o">=</span> <span class="n">values</span><span class="o">!.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="k">as!</span> <span class="kt">C</span> <span class="p">}</span> <span class="c1">// transformed has type [C]</span>
</code></pre></div></div>

<p>Note that in many cases you won’t see a change in behavior:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="o">!</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">transformed</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div></div>

<p>This continues to work as it did before because there is no way to type check the expression successfully if you call the <code class="language-plaintext highlighter-rouge">map(_:)</code> on <code class="language-plaintext highlighter-rouge">Optional</code>. Instead, we end up force-unwrapping <code class="language-plaintext highlighter-rouge">values</code> and calling <code class="language-plaintext highlighter-rouge">map(_:)</code> on the resulting array.</p>

<h3 id="you-cant-infer-a-type-that-isnt-a-type">You Can’t Infer a Type that isn’t a Type</h3>

<p>Because implicitly unwrapped optionals are no longer a type distinct from optionals, they can’t be inferred as a type or as any part of a type.</p>

<p>In the examples below, although the right-hand side of the assignment contains a value that was declared as implicitly unwrapped, the inferred type for the left-hand side only indicates that the value (or return value) is an optional.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="o">!</span>
<span class="k">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="n">x</span>   <span class="c1">// y has type Int?</span>

<span class="kd">func</span> <span class="nf">forcedResult</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="o">!</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">getValue</span> <span class="o">=</span> <span class="n">forcedResult</span>    <span class="c1">// getValue has type () -&gt; Int?</span>

<span class="kd">func</span> <span class="n">id</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">z</span> <span class="o">=</span> <span class="nf">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1">// z has type Int?</span>

<span class="kd">func</span> <span class="n">apply</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">fn</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">fn</span><span class="p">()</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">w</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nf">apply</span><span class="p">(</span><span class="n">forcedResult</span><span class="p">)</span>    <span class="c1">// fails, because apply() returns unforced Int?</span>
</code></pre></div></div>

<p>Some specific instances where you might also notice this change in behavior are in <code class="language-plaintext highlighter-rouge">AnyObject</code> lookup, <code class="language-plaintext highlighter-rouge">try?</code>, and <code class="language-plaintext highlighter-rouge">switch</code>.</p>

<h4 id="anyobject-lookup">AnyObject Lookup</h4>

<p>Note that the result of <code class="language-plaintext highlighter-rouge">AnyObject</code> lookup is treated as an optional that is implicitly unwrapped. If you lookup a property that itself is also declared as implicitly unwrapped, the expression now has two levels of implicit unwrapping (<code class="language-plaintext highlighter-rouge">property</code> is declared as a <code class="language-plaintext highlighter-rouge">UILabel!</code>):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">getLabel</span><span class="p">(</span><span class="nv">object</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UILabel</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">object</span><span class="o">.</span><span class="n">property</span> <span class="c1">// forces both optionals, resulting in a UILabel</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">if let</code> and <code class="language-plaintext highlighter-rouge">guard let</code> only unwrap a single level of optionality.</p>

<p>For the following example, previous versions of Swift inferred the type of <code class="language-plaintext highlighter-rouge">label</code> to be <code class="language-plaintext highlighter-rouge">UILabel!</code> after unwrapping one level of optional for the <code class="language-plaintext highlighter-rouge">if let</code>. In the snapshot builds Swift will infer it to be <code class="language-plaintext highlighter-rouge">UILabel?</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// label is inferred to be UILabel?</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="n">object</span><span class="o">.</span><span class="n">property</span> <span class="p">{</span> 
   <span class="c1">// Error due to passing a UILabel? where a UILabel is expected</span>
  <span class="nf">functionTakingLabel</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This can be fixed by using an explicit type:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Implicitly unwrap object.property due to explicit type.</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">label</span><span class="p">:</span> <span class="kt">UILabel</span> <span class="o">=</span> <span class="n">object</span><span class="o">.</span><span class="n">property</span> <span class="p">{</span>
  <span class="nf">functionTakingLabel</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="c1">// okay</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="try">try?</h4>

<p>Similarly, <code class="language-plaintext highlighter-rouge">try?</code> adds a level of optionality, so when combining <code class="language-plaintext highlighter-rouge">try?</code> with a function that returns an implicitly unwrapped value, you might find that you now need to modify code to explicitly unwrap a second level of optionality.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="o">!</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span>    <span class="c1">// error: x is an Int?</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// explicitly typed as Int</span>
  <span class="k">let</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span>    <span class="c1">// okay, x is an Int</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="nf">test</span><span class="p">(),</span> <span class="k">let</span> <span class="nv">y</span> <span class="o">=</span> <span class="n">x</span> <span class="p">{</span> <span class="c1">// okay, x is Int?, y is Int</span>
 <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="switch">switch</h4>

<p>Swift 4.1 accepted the following code because it treated <code class="language-plaintext highlighter-rouge">output</code> as implicitly unwrapped:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">switchExample</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">"okay"</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"fine"</span>
  <span class="k">case</span> <span class="k">let</span> <span class="nv">output</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">output</span>  <span class="c1">// implicitly unwrap the optional, producing a String</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that had this been written in this way, it would not have compiled successfully:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">switchExample</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">output</span> <span class="o">=</span> <span class="n">input</span>  <span class="c1">// output is inferred to be String?</span>
  <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">"okay"</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"fine"</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">output</span>  <span class="c1">// error: value of optional type 'String?' not unwrapped;</span>
                   <span class="c1">// did you mean to use '!' or '?'?</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The new implementation infers the type of <code class="language-plaintext highlighter-rouge">output</code> in the first example to be a <code class="language-plaintext highlighter-rouge">String?</code> which is not implicitly unwrapped.</p>

<p>One way to get this compiling again is to force-unwrap the value:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">let</span> <span class="nv">output</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">output</span><span class="o">!</span>
</code></pre></div></div>

<p>Another fix for this is to pattern match explicitly for non-nil and nil:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">switchExample</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
  <span class="k">case</span> <span class="s">"okay"</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"fine"</span>
  <span class="k">case</span> <span class="k">let</span> <span class="nv">output</span><span class="p">?:</span> <span class="c1">// non-nil case</span>
    <span class="k">return</span> <span class="n">output</span>   <span class="c1">// okay; output is a String</span>
  <span class="k">case</span> <span class="nv">nil</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"&lt;empty&gt;"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="overloading-in-out-parameters-with-optional-versus-implicitly-unwrapped-optional">Overloading In-Out Parameters with Optional Versus Implicitly Unwrapped Optional</h3>

<p>Swift 4.1 introduced a deprecation warning for cases where code attempts to overload a function where the difference is that an in-out parameter is a plain optional versus an implicitly unwrapped optional.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">someKindOfOptional</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">?)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="c1">// Warning in Swift 4.1.  Error in new implementation.</span>
  <span class="kd">func</span> <span class="nf">someKindOfOptional</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>Swift 4.1 also added the ability to pass a value declared as implicitly unwrapped as an in-out parameter to a function expecting a plain optional and vice-versa. This made it possible to delete the second overload above (assuming the implementations are identical):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">func</span> <span class="nf">someKindOfOptional</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">?)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

  <span class="k">var</span> <span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="o">!</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="nf">someKindOfOptional</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>   <span class="c1">// okay! i has type Optional&lt;Int&gt;</span>
</code></pre></div></div>

<p>With the new implementation of implicitly unwrapped optionals, overloading by optionality no longer makes sense given that the type of <code class="language-plaintext highlighter-rouge">Int!</code> is a synonym for <code class="language-plaintext highlighter-rouge">Int?</code>. As a result, overloads like those above will now result in an error, and second overload (declared with <code class="language-plaintext highlighter-rouge">Int!</code>) must be be removed.</p>

<h3 id="extensions-of-implicitlyunwrappedoptional">Extensions of ImplicitlyUnwrappedOptional</h3>

<p><code class="language-plaintext highlighter-rouge">ImplicitlyUnwrappedOptional&lt;T&gt;</code> is now an unavailable type alias for <code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code>, and code that attempts to create extensions on the type won’t compile:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1:11: error: 'ImplicitlyUnwrappedOptional' has been renamed to 'Optional'</span>
<span class="kd">extension</span> <span class="kt">ImplicitlyUnwrappedOptional</span> <span class="p">{</span>
</code></pre></div></div>

<h3 id="bridging-nil">Bridging Nil</h3>

<p>Rather than hitting a runtime failure when bridging <code class="language-plaintext highlighter-rouge">nil</code> values, <code class="language-plaintext highlighter-rouge">nil</code> will be bridged to <code class="language-plaintext highlighter-rouge">NSNull</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="kd">class</span> <span class="kt">C</span><span class="p">:</span> <span class="kt">NSObject</span> <span class="p">{}</span>

<span class="k">let</span> <span class="nv">iuoElement</span><span class="p">:</span> <span class="kt">C</span><span class="o">!</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="k">let</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">iuoElement</span> <span class="k">as</span> <span class="kt">Any</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">ns</span> <span class="o">=</span> <span class="n">array</span> <span class="k">as</span> <span class="kt">NSArray</span>
<span class="k">let</span> <span class="nv">element</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// Swift 4.1: Fatal error: Attempt to bridge</span>
                    <span class="c1">// an implicitly unwrapped optional containing nil</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">element</span> <span class="k">as?</span> <span class="kt">NSNull</span><span class="p">,</span> <span class="n">value</span> <span class="o">==</span> <span class="kt">NSNull</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"pass"</span><span class="p">)</span>     <span class="c1">// We reach this statement with the new implementation</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"fail"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Implicitly unwrapped optionals have been reimplemented such that they are no longer a distinct type from <code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code>. As a result, type checking is more consistent and there are fewer special cases in the compiler. Removing these special cases should lead to fewer bugs in handling of these declarations.</p>

<p>You’ll probably be exposed to implicit unwrapping as a result of interacting with imported Objective-C APIs. You might occasionally find it convenient to use implicit unwrapping when declaring <code class="language-plaintext highlighter-rouge">@IBOutlet</code> properties, or in other places where you <em>know</em> you won’t access a value until it has been fully initialized. However, you are usually better off avoiding implicit unwrapping and should use explicit unwrapping through <code class="language-plaintext highlighter-rouge">if let</code> and <code class="language-plaintext highlighter-rouge">guard let</code>. When you’re certain it’s safe, use explicit force-unwrapping via <code class="language-plaintext highlighter-rouge">!</code>.</p>

<h2 id="questions-comments">Questions? Comments?</h2>

<p>If you have questions or comments about this post, please feel free to follow up on <a href="https://forums.swift.org/t/swift-org-blog-reimplementation-of-implicitly-unwrapped-optionals/12175">this related thread</a> in the Swift forum.</p>


  
  <footer>
    <nav>
      
      <a href="/blog/swift-4.1-released/" rel="prev" title="Previous: Swift 4.1 Released!">Swift 4.1 Released!</a>
      

      
      <a href="/blog/swift-community-hosted-CI/" rel="next" title="Next: Swift Community-Hosted Continuous Integration">Swift Community-Hosted Continuous Integration</a>
      
    </nav>
  </footer>
  
</article>
</main>



<footer role="contentinfo">
  <div class="footer-content">
    
  <p>Except where otherwise noted, all content on this blog is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.</p>

    <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
    <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
    <p class="privacy">
      <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
      <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
    </p>
  </div>
  <div class="footer-other">
    <form
      class="color-scheme-toggle"
      role="radiogroup"
      tabindex="0"
      id="color-scheme-toggle"
    >
      <legend class="visuallyhidden">Color scheme preference</legend>
      <label for="scheme-light">
        <input id="scheme-light" type="radio" name="color-scheme-preference" value="light">
        <span class="color-scheme-toggle-label">Light</span>
      </label>
      <label for="scheme-dark">
        <input id="scheme-dark" type="radio" name="color-scheme-preference" value="dark">
        <span class="color-scheme-toggle-label">Dark</span>
      </label>
      <label for="scheme-auto" id="scheme-auto-wrapper">
        <input id="scheme-auto" type="radio" name="color-scheme-preference" value="auto">
        <span class="color-scheme-toggle-label">Auto</span>
      </label>
    </form>
    <aside>
      <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter"></i></a>
      <a href="/atom.xml" title="Subscribe to Site Updates"><i class="feed"></i></a>
    </aside>
  </div>
</footer>


<script src="/assets/javascripts/application.js"></script>
<!-- metrics -->
<script>
    /* RSID: */
    var s_account="awdswiftorg"
</script>
<script src="https://developer.apple.com/assets/metrics/scripts/analytics.js"></script>
<script>
    s.pageName= AC && AC.Tracking && AC.Tracking.pageName();

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)
</script>
<!-- /metrics -->
</body>
</html>
