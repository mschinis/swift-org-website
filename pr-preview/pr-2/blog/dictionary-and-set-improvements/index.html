<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Swift.org - Dictionary and Set Improvements in Swift 4.0</title>
  <meta name="author" content="Apple Inc." />
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <link rel="license" href="/LICENSE.txt" />
  <link rel="stylesheet" media="all" href="https://swift.org/assets/stylesheets/application.css" />
  <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="https://swift.org/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
  <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" />
  

  
  <link rel="canonical" href="https://swift.org/blog/dictionary-and-set-improvements/" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@SwiftLang" />
  
  <meta name="twitter:title" content="Dictionary and Set Improvements in Swift 4.0" />
  <meta name="twitter:description" content="In the latest release of Swift,
dictionaries and sets gain a number of new methods and initializers
that make common tasks easier than ever.
Operations like grouping, filtering, and transforming values
can now be performed in a single step,
letting you write more expressive and efficient code.
" />
  

  <meta property="og:site_name" content="Swift.org" />
  <meta property="og:image" content="https://swift.org/apple-touch-icon-180x180.png" />
  
  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Dictionary and Set Improvements in Swift 4.0" />
  <meta property="og:url" content="https://swift.org/blog/dictionary-and-set-improvements/" />
  <meta property="og:description" content="In the latest release of Swift,
dictionaries and sets gain a number of new methods and initializers
that make common tasks easier than ever.
Operations like grouping, filtering, and transforming values
can now be performed in a single step,
letting you write more expressive and efficient code.
" />
  <meta property="article:published_time" content="2017-10-04T08:00:00-04:00" />
  <meta property="article:modified_time" content="2022-06-14T07:25:19-04:00" />
  
</head>

<body>
<script src="https://swift.org/assets/javascripts/color-scheme-toggle.js"></script>
<nav role="navigation">
  <div class="nav-menu-container">
    <header class="menu-item logo-container" role="banner">
      <h1 id="logo">
        <a href="/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>
    <div id="menu-toggle" class="menu-item menu-toggle open"></div>
  </div>

  <div class="list-items">
    
    
    <ul>
      
      
      <li>
      
        <a href="/about/">About Swift</a>
        
      </li>
      
      
      <li>
      
        <a href="/blog/">Blog</a>
        
      </li>
      
      
      <li>
      
        <a href="/getting-started/">Getting Started</a>
        
      </li>
      
      
      <li>
      
        <a href="/download/">Download</a>
        
      </li>
      
      
      <li>
      
        <a href="/platform-support/">Platform Support</a>
        
      </li>
      
      
      <li>
      
        <a href="/documentation/">Documentation</a>
        
      </li>
      
    </ul>
    
    
    <h2>Community</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/community/">Community Overview</a>
        
      </li>
      
      
      <li>
      
        <a href="/diversity/">Diversity</a>
        
      </li>
      
      
      <li>
      
        <a href="/mentorship/">Mentorship</a>
        
      </li>
      
      
      <li>
      
        <a href="/contributing/">Contributing</a>
        
      </li>
      
      
      <li>
      
        <a href="/code-of-conduct/">Code of Conduct</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Development</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/source-code/">Source Code</a>
        
      </li>
      
      
      <li>
      
        <a href="/continuous-integration/">Continuous Integration</a>
        
      </li>
      
      
      <li>
      
        <a href="/source-compatibility/">Source Compatibility</a>
        
      </li>
      
      
      <li>
      
        <a href="/support/security.html">Security</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Efforts</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/swift-compiler/">Swift Compiler</a>
        
      </li>
      
      
      <li>
      
        <a href="/standard-library/">Standard Library</a>
        
      </li>
      
      
      <li>
      
        <a href="/package-manager/">Package Manager</a>
        
      </li>
      
      
      <li>
      
        <a href="/core-libraries/">Core Libraries</a>
        
      </li>
      
      
      <li>
      
        <a href="/lldb/">REPL, Debugger & Playgrounds</a>
        
      </li>
      
      
      <li>
      
        <a href="/server/">Swift on Server</a>
        
      </li>
      
      
      <li>
      
        <a href="/website/">Swift.org website</a>
        
      </li>
      
    </ul>
    
  </div>
</nav>

<main role="main">
<article class="post">
  <header>
    <h1>Dictionary and Set Improvements in Swift 4.0</h1>

    <time pubdate datetime="2017-10-04T08:00:00-04:00">October 4, 2017</time>
    
    
    
      <div class="byline">
        
          <img src="https://s.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=64" alt="Nate Cook"/>
        

        <span class="author">
          
            <a href="https://twitter.com/nnnnnnnn/" rel="nofollow" title="Nate Cook (@nnnnnnnn) on Twitter">Nate Cook</a>
          
        </span>
      </div>
      
      <div class="about">Nate Cook is a member of the Swift standard library team at Apple.</div>
      
    
    
  </header>

  <p>In the latest release of Swift,
dictionaries and sets gain a number of new methods and initializers
that make common tasks easier than ever.
Operations like grouping, filtering, and transforming values
can now be performed in a single step,
letting you write more expressive and efficient code.</p>

<p>This post explores these new transformations,
using some grocery data for a market as an example.
This custom <code class="language-plaintext highlighter-rouge">GroceryItem</code> struct,
made up of a name and a department,
will serve as the data type:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">GroceryItem</span><span class="p">:</span> <span class="kt">Hashable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">var</span> <span class="nv">department</span><span class="p">:</span> <span class="kt">Department</span>

    <span class="kd">enum</span> <span class="kt">Department</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">bakery</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="n">seafood</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">GroceryItem</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">GroceryItem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">lhs</span><span class="o">.</span><span class="n">department</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">department</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="c1">// Combine the hash values for the name and department</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">department</span><span class="o">.</span><span class="n">hashValue</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Create some groceries for our store:</span>
<span class="k">let</span> <span class="nv">üçé</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Apples"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">produce</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">üçå</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Bananas"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">produce</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">ü•ê</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Croissants"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">bakery</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">üêü</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Salmon"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">seafood</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">üçá</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Grapes"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">produce</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">üçû</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Bread"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">bakery</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">üç§</span> <span class="o">=</span> <span class="kt">GroceryItem</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Shrimp"</span><span class="p">,</span> <span class="nv">department</span><span class="p">:</span> <span class="o">.</span><span class="n">seafood</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">groceries</span> <span class="o">=</span> <span class="p">[</span><span class="n">üçé</span><span class="p">,</span> <span class="n">üçå</span><span class="p">,</span> <span class="n">ü•ê</span><span class="p">,</span> <span class="n">üêü</span><span class="p">,</span> <span class="n">üçá</span><span class="p">,</span> <span class="n">üçû</span><span class="p">,</span> <span class="n">üç§</span><span class="p">]</span>
</code></pre></div></div>

<p>The examples that follow use the <code class="language-plaintext highlighter-rouge">groceries</code> array
to build and transform dictionaries with these new tools.</p>

<h2 id="grouping-values-by-a-key">Grouping Values by a Key</h2>

<p><img alt="Grouping groceries by their department" src="https://swift.org/assets/images/dictionary-blog/grouping.png" srcset="https://swift.org/assets/images/dictionary-blog/grouping_2x.png 2x" class="dictionary-blog" /></p>

<p>A new grouping initializer makes it a snap
to build a dictionary from a sequence of values,
grouped by keys computed from those values.
We‚Äôll use this new initializer to build a dictionary of groceries
grouped by their department.</p>

<p>To do this in earlier versions of Swift,
you used iteration to build up a dictionary from scratch.
This required type annotations, manual iteration,
and a check to see if each key already existed in the dictionary.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift &lt;= 3.1</span>
<span class="k">var</span> <span class="nv">grouped</span><span class="p">:</span> <span class="p">[</span><span class="kt">GroceryItem</span><span class="o">.</span><span class="kt">Department</span><span class="p">:</span> <span class="p">[</span><span class="kt">GroceryItem</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[:]</span>
<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">groceries</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">grouped</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">department</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="n">grouped</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">department</span><span class="p">]</span><span class="o">!.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">grouped</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">department</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this update to Swift,
you can use the <code class="language-plaintext highlighter-rouge">Dictionary(grouping:by)</code> initializer to create the same dictionary
with a single line of code.
Pass a closure that returns a key for each element in your array.
In the following code, the closure returns the department for each grocery item:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 4.0</span>
<span class="k">let</span> <span class="nv">groceriesByDepartment</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="p">(</span><span class="nv">grouping</span><span class="p">:</span> <span class="n">groceries</span><span class="p">,</span>
                                       <span class="nv">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">item</span> <span class="k">in</span> <span class="n">item</span><span class="o">.</span><span class="n">department</span> <span class="p">})</span>
<span class="c1">// groceriesByDepartment[.bakery] == [ü•ê, üçû]</span>
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">groceriesByDepartment</code> dictionary
has an entry for each department in the list of groceries.
The value for each key is an array of the groceries within that department,
in the same order as the original list.
Using <code class="language-plaintext highlighter-rouge">.bakery</code> as a key in <code class="language-plaintext highlighter-rouge">groceriesByDepartment</code> gives you the array <code class="language-plaintext highlighter-rouge">[ü•ê, üçû]</code>.</p>

<h2 id="transforming-a-dictionarys-values">Transforming a Dictionary‚Äôs Values</h2>

<p>You can transform the values of a dictionary,
while keeping the same keys,
by using the new <code class="language-plaintext highlighter-rouge">mapValues(_:)</code> method.
This code transforms the arrays of items in <code class="language-plaintext highlighter-rouge">groceriesByDepartment</code> into their counts,
creating a lookup table for the number of items in each department:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">departmentCounts</span> <span class="o">=</span> <span class="n">groceriesByDepartment</span><span class="o">.</span><span class="n">mapValues</span> <span class="p">{</span> <span class="n">items</span> <span class="k">in</span> <span class="n">items</span><span class="o">.</span><span class="n">count</span> <span class="p">}</span>
<span class="c1">// departmentCounts[.bakery] == 2</span>
</code></pre></div></div>

<p>Because the dictionary has all the same keys, 
just with different values, 
it can use the same internal layout as the original dictionary 
and doesn‚Äôt need to recompute any hash values. 
This makes calling <code class="language-plaintext highlighter-rouge">mapValues(_:)</code> faster 
than rebuilding the dictionary from scratch.</p>

<h2 id="building-dictionaries-from-key-value-pairs">Building Dictionaries from Key-Value Pairs</h2>

<p><img alt="Building a dictionary from names and values" src="https://swift.org/assets/images/dictionary-blog/uniqueKeys.png" srcset="https://swift.org/assets/images/dictionary-blog/uniqueKeys_2x.png 2x" class="dictionary-blog" /></p>

<p>You can now create dictionaries
from sequences of key-value pairs
using two different initializers:
one for when you have unique keys,
and one for when you might have keys that repeat.</p>

<p>If you start with a sequence of keys and a sequence of values,
you can combine them 
into a single sequence of pairs 
using the <code class="language-plaintext highlighter-rouge">zip(_:_:)</code> function.
For example,
this code creates a sequence of tuples
with the name of a grocery item and the item itself:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">zippedNames</span> <span class="o">=</span> <span class="nf">zip</span><span class="p">(</span><span class="n">groceries</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">name</span> <span class="p">},</span> <span class="n">groceries</span><span class="p">)</span>
</code></pre></div></div>

<p>Each element of <code class="language-plaintext highlighter-rouge">zippedNames</code> is a <code class="language-plaintext highlighter-rouge">(String, GroceryItem)</code> tuple,
the first of which is <code class="language-plaintext highlighter-rouge">("Apples", üçé)</code>.
Because every grocery item has a unique name,
the following code successfully creates a dictionary
that uses names as keys for grocery items:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">groceriesByName</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="p">(</span><span class="nv">uniqueKeysWithValues</span><span class="p">:</span> <span class="n">zippedNames</span><span class="p">)</span>
<span class="c1">// groceriesByName["Apples"] == üçé</span>
<span class="c1">// groceriesByName["Kumquats"] == nil</span>
</code></pre></div></div>

<p>Use the <code class="language-plaintext highlighter-rouge">Dictionary(uniqueKeysWithValues:)</code> initializer only when you‚Äôre sure
that your data has unique keys.
Any duplicated keys in the sequence will trigger a runtime error.</p>

<p>If your data has (or might have) repeated keys,
use the new merging initializer, <code class="language-plaintext highlighter-rouge">Dictionary(_:uniquingKeysWith:)</code>.
This initializer takes a sequence of key-value pairs
along with a closure that is called whenever a key is repeated.
The <em>uniquing</em> closure takes the first and second value
that share the same key as arguments,
and can return the existing value,
the new value,
or combine them however you decide.</p>

<p>For example,
the following code converts an array of <code class="language-plaintext highlighter-rouge">(String, String)</code> tuples
into a dictionary by using <code class="language-plaintext highlighter-rouge">Dictionary(_:uniquingKeysWith:)</code>.
Note that <code class="language-plaintext highlighter-rouge">"dog"</code> is the key in two of the key-value pairs.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"dog"</span><span class="p">,</span> <span class="s">"üêï"</span><span class="p">),</span> <span class="p">(</span><span class="s">"cat"</span><span class="p">,</span> <span class="s">"üê±"</span><span class="p">),</span> <span class="p">(</span><span class="s">"dog"</span><span class="p">,</span> <span class="s">"üê∂"</span><span class="p">),</span> <span class="p">(</span><span class="s">"bunny"</span><span class="p">,</span> <span class="s">"üê∞"</span><span class="p">)]</span>
<span class="k">let</span> <span class="nv">petmoji</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span>
                         <span class="nv">uniquingKeysWith</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="k">new</span><span class="p">)</span> <span class="k">in</span> <span class="k">new</span> <span class="p">})</span>
<span class="c1">// petmoji["cat"] == "üê±"</span>
<span class="c1">// petmoji["dog"] == "üê∂"</span>
</code></pre></div></div>

<p>When the second key-value pair with the key <code class="language-plaintext highlighter-rouge">"dog"</code> is reached,
the uniquing closure is called with the old and new values (<code class="language-plaintext highlighter-rouge">"üêï"</code> and <code class="language-plaintext highlighter-rouge">"üê∂"</code>).
Because the closure always returns its second parameter,
the result has <code class="language-plaintext highlighter-rouge">"üê∂"</code> as the value for the <code class="language-plaintext highlighter-rouge">"dog"</code> key.</p>

<h2 id="selecting-certain-entries">Selecting Certain Entries</h2>

<p>Dictionaries now have a <code class="language-plaintext highlighter-rouge">filter(_:)</code> method that returns a dictionary,
not just an array of key-value pairs,
like in earlier versions of Swift.
Pass a closure that takes a key-value pair as its argument
and returns <code class="language-plaintext highlighter-rouge">true</code> if that pair should be in the result.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">isOutOfStock</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">GroceryItem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// Looks up `item` in inventory</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">outOfStock</span> <span class="o">=</span> <span class="n">groceriesByName</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">in</span> <span class="nf">isOutOfStock</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">}</span>
<span class="c1">// outOfStock["Croissants"] == ü•ê</span>
<span class="c1">// outOfStock["Apples"] == nil</span>
</code></pre></div></div>

<p>This code calls an <code class="language-plaintext highlighter-rouge">isOutOfStock(_:)</code> function on each item,
keeping only the grocery items that are out of stock.</p>

<h2 id="using-default-values">Using Default Values</h2>

<p>Dictionaries now have a second key-based subscript
that makes it easier to get and update values.
The following code defines a simple shopping cart,
implemented as a dictionary of items and their counts:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Begin with a single banana</span>
<span class="k">var</span> <span class="nv">cart</span> <span class="o">=</span> <span class="p">[</span><span class="nv">üçå</span><span class="p">:</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Because some keys may not have corresponding values in the dictionary,
when you use a key to look up a value, the result is optional.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// One banana:</span>
<span class="n">cart</span><span class="p">[</span><span class="n">üçå</span><span class="p">]</span>    <span class="c1">// Optional(1)</span>
<span class="c1">// But no shrimp:</span>
<span class="n">cart</span><span class="p">[</span><span class="n">üç§</span><span class="p">]</span>    <span class="c1">// nil</span>
</code></pre></div></div>

<p>Instead of using the nil coalescing operator (<code class="language-plaintext highlighter-rouge">??</code>)
to turn optional values into the actual count you need,
you can now subscript a dictionary with a key and a <code class="language-plaintext highlighter-rouge">default</code> parameter.
If the key is found,
its value is returned and the default is ignored.
If the key isn‚Äôt found,
the subscript returns the default value you provided.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Still one banana:</span>
<span class="n">cart</span><span class="p">[</span><span class="n">üçå</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span>    <span class="c1">// 1</span>
<span class="c1">// And zero shrimp:</span>
<span class="n">cart</span><span class="p">[</span><span class="n">üç§</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span>    <span class="c1">// 0</span>
</code></pre></div></div>

<p>You can even modify a value through the new subscript,
simplifying the code needed to add new items to the cart.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="p">[</span><span class="n">üçå</span><span class="p">,</span> <span class="n">üçå</span><span class="p">,</span> <span class="n">üçû</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">cart</span><span class="p">[</span><span class="n">item</span><span class="p">,</span> <span class="k">default</span><span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When this loop processes each banana (<code class="language-plaintext highlighter-rouge">üçå</code>),
the current value is retrieved, incremented,
and stored back into the dictionary.
When it‚Äôs time to add the loaf of bread (<code class="language-plaintext highlighter-rouge">üçû</code>),
the dictionary doesn‚Äôt find the key,
and instead returns the <em>default value</em> (<code class="language-plaintext highlighter-rouge">0</code>).
After that value is incremented,
the dictionary adds the new key-value pair.</p>

<p>At the end of the loop, <code class="language-plaintext highlighter-rouge">cart</code> is <code class="language-plaintext highlighter-rouge">[üçå: 3, üçû: 1]</code>.</p>

<h2 id="merging-two-dictionaries-into-one">Merging Two Dictionaries into One</h2>

<p>In addition to easier incremental changes,
dictionaries now make it simpler to make changes in bulk,
with methods that merge one dictionary into another.</p>

<p><img alt="Merging two carts together" src="https://swift.org/assets/images/dictionary-blog/merging.png" srcset="https://swift.org/assets/images/dictionary-blog/merging_2x.png 2x" class="dictionary-blog" /></p>

<p>To merge the contents of <code class="language-plaintext highlighter-rouge">cart</code> and another dictionary,
you can use the mutating <code class="language-plaintext highlighter-rouge">merge(_:uniquingKeysWith:)</code> method.
The uniquing closure that you pass works the same way
as in the <code class="language-plaintext highlighter-rouge">Dictionary(_:uniquingKeysWith:)</code> initializer:
It‚Äôs called whenever there are two values with the same key,
and returns one, the other, or a combination of the values.</p>

<p>In this example,
passing the addition operator as the <code class="language-plaintext highlighter-rouge">uniquingKeysWith</code> parameter
adds together any counts for matching keys,
so the updated cart has the correct total for each item:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">otherCart</span> <span class="o">=</span> <span class="p">[</span><span class="nv">üçå</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">üçá</span><span class="p">:</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">cart</span><span class="o">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">otherCart</span><span class="p">,</span> <span class="nv">uniquingKeysWith</span><span class="p">:</span> <span class="o">+</span><span class="p">)</span>
<span class="c1">// cart == [üçå: 5, üçá: 3, üçû: 1]</span>
</code></pre></div></div>

<p>To create a new dictionary
with the merged contents instead of merging in place,
use the nonmutating <code class="language-plaintext highlighter-rouge">merging(_:uniquingKeysWith:)</code> method.</p>

<h2 id="and-thats-not-all">And That‚Äôs Not All‚Ä¶</h2>

<p>There are a few more additions we haven‚Äôt covered.
Dictionaries now have custom <code class="language-plaintext highlighter-rouge">keys</code> and <code class="language-plaintext highlighter-rouge">values</code> collections with new capabilities.
The <code class="language-plaintext highlighter-rouge">keys</code> collection maintains fast key lookup,
while the mutable <code class="language-plaintext highlighter-rouge">values</code> collection lets you modify values in place.</p>

<p>Like dictionaries,
sets gain a new <code class="language-plaintext highlighter-rouge">filter(_:)</code> method that returns a set of the same type,
instead of an array like in earlier versions of Swift.
And finally,
both sets and dictionaries now expose their current capacity
and add a <code class="language-plaintext highlighter-rouge">reserveCapacity(_:)</code> method.
With these additions you can see and control the size of their internal storage.</p>

<p>Other than the custom <code class="language-plaintext highlighter-rouge">keys</code> and <code class="language-plaintext highlighter-rouge">values</code> collections,
all these changes are available in Swift 3.2.
Even if you haven‚Äôt yet switched to using Swift 4.0,
you can start taking advantage of these improvements today!</p>

<p>You can find more information about all these new capabilities
in the <a href="https://developer.apple.com/documentation/swift/dictionary">Dictionary</a> and <a href="https://developer.apple.com/documentation/swift/set">Set</a> documentation,
or read more about the rationale behind the additions
in the Swift Evolution proposals for the
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0154-dictionary-key-and-value-collections.md">custom <code class="language-plaintext highlighter-rouge">keys</code> and <code class="language-plaintext highlighter-rouge">values</code> collections</a> and
<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0165-dict.md">other dictionary and set enhancements</a>.</p>

<style type="text/css">
img.dictionary-blog {
    float: right;
    padding: 10px;
}
pre {
    clear: right;
}
@media only screen and (max-width: 480px) {
    img.dictionary-blog {
        float: none;
        padding: 0;
        width: 100%;
        margin: 1em 0 0;
    }
}
</style>



  
  <footer>
    <nav>
      
      <a href="/blog/swift-4.0-released/" rel="prev" title="Previous: Swift 4.0 Released!">Swift 4.0 Released!</a>
      

      
      <a href="/blog/xcode-9.1-improves-display-of-fatal-errors/" rel="next" title="Next: Xcode 9.1 Improves Display of Fatal Errors">Xcode 9.1 Improves Display of Fatal Errors</a>
      
    </nav>
  </footer>
  
</article>
</main>



<footer role="contentinfo">
  <div class="footer-content">
    
  <p>Except where otherwise noted, all content on this blog is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.</p>

    <p class="copyright">Copyright ¬© 2022 Apple Inc. All rights reserved.</p>
    <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
    <p class="privacy">
      <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
      <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
    </p>
  </div>
  <div class="footer-other">
    <form
      class="color-scheme-toggle"
      role="radiogroup"
      tabindex="0"
      id="color-scheme-toggle"
    >
      <legend class="visuallyhidden">Color scheme preference</legend>
      <label for="scheme-light">
        <input id="scheme-light" type="radio" name="color-scheme-preference" value="light">
        <span class="color-scheme-toggle-label">Light</span>
      </label>
      <label for="scheme-dark">
        <input id="scheme-dark" type="radio" name="color-scheme-preference" value="dark">
        <span class="color-scheme-toggle-label">Dark</span>
      </label>
      <label for="scheme-auto" id="scheme-auto-wrapper">
        <input id="scheme-auto" type="radio" name="color-scheme-preference" value="auto">
        <span class="color-scheme-toggle-label">Auto</span>
      </label>
    </form>
    <aside>
      <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter"></i></a>
      <a href="/atom.xml" title="Subscribe to Site Updates"><i class="feed"></i></a>
    </aside>
  </div>
</footer>


<script src="https://swift.org/assets/javascripts/application.js"></script>
<!-- metrics -->
<script>
    /* RSID: */
    var s_account="awdswiftorg"
</script>
<script src="https://developer.apple.com/assets/metrics/scripts/analytics.js"></script>
<script>
    s.pageName= AC && AC.Tracking && AC.Tracking.pageName();

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)
</script>
<!-- /metrics -->
</body>
</html>
