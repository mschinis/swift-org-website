<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Swift.org - Swift Local Refactoring</title>
  <meta name="author" content="Apple Inc." />
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <link rel="license" href="/LICENSE.txt" />
  <link rel="stylesheet" media="all" href="/assets/stylesheets/application.css" />
  <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
  <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" />
  

  
  <link rel="canonical" href="https://swift.org/blog/swift-local-refactoring/" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@SwiftLang" />
  
  <meta name="twitter:title" content="Swift Local Refactoring" />
  <meta name="twitter:description" content="Xcode 9 includes a brand new refactoring engine. It can transform code locally
within a single Swift source file, or globally, such as renaming a method or property
that occurs in multiple files and even different languages. The logic behind local refactorings is
implemented entirely in the compiler and SourceKit, and is now open source in
the swift repository. Therefore, any Swift enthusiast can
contribute refactoring actions to the language. This post discusses how
a simple refactoring can be implemented and surfaced in Xcode.
" />
  

  <meta property="og:site_name" content="Swift.org" />
  <meta property="og:image" content="https://swift.org/apple-touch-icon-180x180.png" />
  
  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Swift Local Refactoring" />
  <meta property="og:url" content="https://swift.org/blog/swift-local-refactoring/" />
  <meta property="og:description" content="Xcode 9 includes a brand new refactoring engine. It can transform code locally
within a single Swift source file, or globally, such as renaming a method or property
that occurs in multiple files and even different languages. The logic behind local refactorings is
implemented entirely in the compiler and SourceKit, and is now open source in
the swift repository. Therefore, any Swift enthusiast can
contribute refactoring actions to the language. This post discusses how
a simple refactoring can be implemented and surfaced in Xcode.
" />
  <meta property="article:published_time" content="2017-08-22T05:45:00-04:00" />
  <meta property="article:modified_time" content="2022-06-14T07:08:53-04:00" />
  
</head>

<body>
<script src="/assets/javascripts/color-scheme-toggle.js"></script>
<nav role="navigation">
  <div class="nav-menu-container">
    <header class="menu-item logo-container" role="banner">
      <h1 id="logo">
        <a href="/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>
    <div id="menu-toggle" class="menu-item menu-toggle open"></div>
  </div>

  <div class="list-items">
    
    
    <ul>
      
      
      <li>
      
        <a href="/about/">About Swift</a>
        
      </li>
      
      
      <li>
      
        <a href="/blog/">Blog</a>
        
      </li>
      
      
      <li>
      
        <a href="/getting-started/">Getting Started</a>
        
      </li>
      
      
      <li>
      
        <a href="/download/">Download</a>
        
      </li>
      
      
      <li>
      
        <a href="/platform-support/">Platform Support</a>
        
      </li>
      
      
      <li>
      
        <a href="/documentation/">Documentation</a>
        
      </li>
      
    </ul>
    
    
    <h2>Community</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/community/">Community Overview</a>
        
      </li>
      
      
      <li>
      
        <a href="/diversity/">Diversity</a>
        
      </li>
      
      
      <li>
      
        <a href="/mentorship/">Mentorship</a>
        
      </li>
      
      
      <li>
      
        <a href="/contributing/">Contributing</a>
        
      </li>
      
      
      <li>
      
        <a href="/code-of-conduct/">Code of Conduct</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Development</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/source-code/">Source Code</a>
        
      </li>
      
      
      <li>
      
        <a href="/continuous-integration/">Continuous Integration</a>
        
      </li>
      
      
      <li>
      
        <a href="/source-compatibility/">Source Compatibility</a>
        
      </li>
      
      
      <li>
      
        <a href="/support/security.html">Security</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Efforts</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/swift-compiler/">Swift Compiler</a>
        
      </li>
      
      
      <li>
      
        <a href="/standard-library/">Standard Library</a>
        
      </li>
      
      
      <li>
      
        <a href="/package-manager/">Package Manager</a>
        
      </li>
      
      
      <li>
      
        <a href="/core-libraries/">Core Libraries</a>
        
      </li>
      
      
      <li>
      
        <a href="/lldb/">REPL, Debugger & Playgrounds</a>
        
      </li>
      
      
      <li>
      
        <a href="/server/">Swift on Server</a>
        
      </li>
      
      
      <li>
      
        <a href="/website/">Swift.org website</a>
        
      </li>
      
    </ul>
    
  </div>
</nav>

<main role="main">
<article class="post">
  <header>
    <h1>Swift Local Refactoring</h1>

    <time pubdate datetime="2017-08-22T05:45:00-04:00">August 22, 2017</time>
    
    
    
      <div class="byline">
        

        <span class="author">
          
            <a href="https://twitter.com/xge_apple/" rel="nofollow" title="Xi Ge (@xge_apple) on Twitter">Xi Ge</a>
          
        </span>
      </div>
      
    
    
  </header>

  <p>Xcode 9 includes a brand new refactoring engine. It can transform code locally
within a single Swift source file, or globally, such as renaming a method or property
that occurs in multiple files and even different languages. The logic behind local refactorings is
implemented entirely in the compiler and SourceKit, and is now open source in
the <a href="https://github.com/apple/swift">swift repository</a>. Therefore, any Swift enthusiast can
contribute refactoring actions to the language. This post discusses how
a simple refactoring can be implemented and surfaced in Xcode.</p>

<h2 id="kinds-of-refactorings">Kinds of Refactorings</h2>

<p>A <strong>local refactoring</strong> occurs within the confines of a single file.
Examples of local refactoring include <em>Extract Method</em> and <em>Extract Repeated Expression</em>.
<strong>Global refactorings</strong>, which change code cross multiple files
(such as <em>Global Rename</em>), currently require special coordination by Xcode and currently
cannot be implemented on their own within the Swift codebase. This post focuses on
local refactorings, which can be quite powerful in their own right.</p>

<p>A refactoring action is initiated by a user’s cursor selection in the editor.
According to how they are initialized, we categorize refactoring actions as cursor-based
or range-based. <strong>Cursor-based refactoring</strong> has a refactoring target sufficiently
specified by a cursor position in a Swift source file, such as rename refactoring.
In contrast, <strong>range-based refactoring</strong> needs a start and end position to specify
its target, such as Extract Method refactoring. To facilitate the implementation
of these two categories, the Swift repository provides pre-analyzed results called
<a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> and <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L344">ResolvedRangeInfo</a> to answer several common questions about a cursor
position or a range in a Swift source file.</p>

<p>For instance, <a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> can tell us whether a location in the source file
points to the start of an expression and, if so, provide the corresponding compiler object of that
expression. Alternatively, if the cursor points to a name, <a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> gives
us the declaration corresponding to that name. Similarly, <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L344">ResolvedRangeInfo</a> encapsulates
information about a given source range, such as whether the range has multiple entry or exit points.</p>

<p>To implement a new refactoring for Swift, we don’t
need to start from the raw representation of a cursor or a range position;
instead, we can start with <a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> and <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L344">ResolvedRangeInfo</a> upon which a refactoring-specific
analysis can be derived.</p>

<h2 id="cursor-based-refactoring">Cursor-based Refactoring</h2>

<p><img src="https://swift.org/assets/images/local-refactoring/Cursor.png" alt="Cursor-based Refactoring" /></p>

<p>Cursor-based refactoring is initiated by a cursor location in a Swift source file.
Refactoring actions implement methods that the refactoring engine uses to display the available actions
on the IDE and to perform the transformations.</p>

<p>Specifically, for displaying the available actions:</p>

<ol>
  <li>The user selects a location from the Xcode editor.</li>
  <li>Xcode makes a request to <a href="https://github.com/apple/swift/tree/master/tools/SourceKit">sourcekitd</a> to see what available refactoring actions exist for that location.</li>
  <li>Each implemented refactoring action is queried with a <code class="language-plaintext highlighter-rouge">ResolvedCursorInfo</code> object to see if the action is applicable for that location.</li>
  <li>The list of applicable actions is returned as response from <a href="https://github.com/apple/swift/tree/master/tools/SourceKit">sourcekitd</a> and displayed to the user by Xcode.</li>
</ol>

<p>When the user selects one of the available actions:</p>

<ol>
  <li>Xcode makes a request to <a href="https://github.com/apple/swift/tree/master/tools/SourceKit">sourcekitd</a> to perform the selected action on the source location.</li>
  <li>The specific refactoring action is queried with a <code class="language-plaintext highlighter-rouge">ResolvedCursorInfo</code> object, derived from the same location, to verify that the action is applicable.</li>
  <li>The refactoring action is asked to perform the transformation with textual source edits.</li>
  <li>The source edits are returned as response from <a href="https://github.com/apple/swift/tree/master/tools/SourceKit">sourcekitd</a> and are applied by the Xcode editor.</li>
</ol>

<p>To implement <em>String Localization</em> refactoring, we need to first declare this
refactoring in the <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/RefactoringKinds.def">RefactoringKinds.def</a> file with an entry like:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">CURSOR_REFACTORING</span><span class="p">(</span><span class="n">LocalizeString</span><span class="p">,</span> <span class="s">"Localize String"</span><span class="p">,</span> <span class="n">localize</span><span class="p">.</span><span class="n">string</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">CURSOR_REFACTORING</code> specifies that this refactoring is initialized at a cursor
location and thus will use <a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> in the implementation. The first field,
<code class="language-plaintext highlighter-rouge">LocalizeString</code>, specifies the internal name of this refactoring in the Swift
codebase. In this example, the class corresponding to this refactoring is named
<code class="language-plaintext highlighter-rouge">RefactoringActionLocalizeString</code>. The string literal <code class="language-plaintext highlighter-rouge">"Localize String"</code> is the
display name for this refactoring to be presented to users in the UI. Finally,
“localize.string” is a stable key that identifies the refactoring action, which
the Swift toolchain uses in communication with the source editor.
This entry also allows
the C++ compiler to generate the class stub for the String Localization refactoring
and its callers. Therefore, we can focus on the implementation of the
required functions.</p>

<p>After specifying this entry, we need to implement two functions to
teach Xcode:</p>

<ol>
  <li>When it is appropriate to show the refactoring action.</li>
  <li>What code change should be applied when a user invokes this refactoring action.</li>
</ol>

<p>Both declarations are automatically generated from the
aforementioned entry. To fulfill (1), we need to implement the <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L646">isApplicable</a> function
of <code class="language-plaintext highlighter-rouge">RefactoringActionLocalizeString</code> in <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp">Refactoring.cpp</a>, as below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kt">bool</span> <span class="n">RefactoringActionLocalizeString</span><span class="o">::</span>
<span class="mi">2</span>  <span class="nf">isApplicable</span><span class="p">(</span><span class="n">ResolvedCursorInfo</span> <span class="n">CursorInfo</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">3</span>    <span class="k">if</span> <span class="p">(</span><span class="n">CursorInfo</span><span class="p">.</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">CursorInfoKind</span><span class="o">::</span><span class="n">ExprStart</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4</span>      <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="n">Literal</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">StringLiteralExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CursorInfo</span><span class="p">.</span><span class="n">TrailingExpr</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">5</span>        <span class="k">return</span> <span class="o">!</span><span class="n">Literal</span><span class="o">-&gt;</span><span class="n">hasInterpolation</span><span class="p">();</span> <span class="c1">// Not real API.</span>
<span class="mi">6</span>      <span class="p">}</span>
<span class="mi">7</span>    <span class="p">}</span>
<span class="mi">8</span>  <span class="p">}</span>
</code></pre></div></div>

<p>Taking a <a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> object as input, it’s almost trivial to check
when to populate the available refactoring menu with
“localize string”. In this case, checking that the cursor points to the start of
an expression (Line 3), and the expression is a string literal (Line 4) without
interpolation (Line 5) is sufficient.</p>

<p>Next, we need to implement how the code under the cursor should be
changed if the refactoring action is applied. To do this, we
have to implement the <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L599">performChange</a> method of <code class="language-plaintext highlighter-rouge">RefactoringActionLocalizeString</code>.
In the implementation of <code class="language-plaintext highlighter-rouge">performChange</code>, we can access the same <code class="language-plaintext highlighter-rouge">ResolvedCursorInfo</code> object that <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L646">isApplicable</a> received.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kt">bool</span> <span class="n">RefactoringActionLocalizeString</span><span class="o">::</span>
<span class="mi">2</span>  <span class="nf">performChange</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">3</span>    <span class="n">EditConsumer</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span> <span class="n">Cursor</span><span class="p">.</span><span class="n">TrailingExpr</span><span class="o">-&gt;</span><span class="n">getStartLoc</span><span class="p">(),</span> <span class="s">"NSLocalizedString("</span><span class="p">);</span>
<span class="mi">4</span>    <span class="n">EditConsumer</span><span class="p">.</span><span class="n">insertAfter</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span> <span class="n">Cursor</span><span class="p">.</span><span class="n">TrailingExpr</span><span class="o">-&gt;</span><span class="n">getEndLoc</span><span class="p">(),</span> <span class="s">", comment: </span><span class="se">\"\"</span><span class="s">)"</span><span class="p">);</span>
<span class="mi">5</span>    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Return true if code change aborted.</span>
<span class="mi">6</span>  <span class="p">}</span>
</code></pre></div></div>

<p>Still using String Localization as an example, the <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L599">performChange</a> function
is fairly straightforward to implement. In the function body, we
can use <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L506">EditConsumer</a> to issue textual edits around the expression pointed by
the cursor with the appropriate Foundation API calls, as Lines 3 and 4 illustrate.</p>

<h2 id="range-based-refactoring">Range-based Refactoring</h2>

<p><img src="https://swift.org/assets/images/local-refactoring/Range.png" alt="Range-based Refactoring" /></p>

<p>As the above figure shows, range-based refactoring is initiated by selecting a
continuous range of code in a Swift source file. Taking the implementation of the <em>Extract Expression</em>
refactoring as an example, we first need to declare the following item in
<a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/RefactoringKinds.def">RefactoringKinds.def</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">RANGE_REFACTORING</span><span class="p">(</span><span class="n">ExtractExpr</span><span class="p">,</span> <span class="s">"Extract Expression"</span><span class="p">,</span> <span class="n">extract</span><span class="p">.</span><span class="n">expr</span><span class="p">)</span>
</code></pre></div></div>

<p>This entry declares that the Extract Expression refactoring is initiated by a range selection,
named internally as <code class="language-plaintext highlighter-rouge">ExtractExpr</code>, using <code class="language-plaintext highlighter-rouge">"Extract Expression"</code> as display name, and with
a stable key of “extract.expr” for service communication purposes.</p>

<p>To teach Xcode when this refactoring should be available, we
also need to implement <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L646">isApplicable</a> for this refactoring in <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp">Refactoring.cpp</a>,
with the slight difference that the input is a <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L344">ResolvedRangeInfo</a> instead of a <a href="https://github.com/apple/swift/blob/7f29b362d68eb990a592257850aabadb24de61df/include/swift/IDE/Utils.h#L158">ResolvedCursorInfo</a> .</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kt">bool</span> <span class="n">RefactoringActionExtractExpr</span><span class="o">::</span>
<span class="mi">2</span>  <span class="nf">isApplicable</span><span class="p">(</span><span class="n">ResolvedRangeInfo</span> <span class="n">Info</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">3</span>    <span class="k">if</span> <span class="p">(</span><span class="n">Info</span><span class="p">.</span><span class="n">Kind</span> <span class="o">!=</span> <span class="n">RangeKind</span><span class="o">::</span><span class="n">SingleExpression</span><span class="p">)</span>
<span class="mi">4</span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">5</span>    <span class="k">auto</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Info</span><span class="p">.</span><span class="n">getType</span><span class="p">();</span>
<span class="mi">6</span>    <span class="k">if</span> <span class="p">(</span><span class="n">Ty</span><span class="p">.</span><span class="n">isNull</span><span class="p">()</span> <span class="o">||</span> <span class="n">Ty</span><span class="p">.</span><span class="n">hasError</span><span class="p">())</span>
<span class="mi">7</span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="mi">8</span>    <span class="p">...</span>
<span class="mi">9</span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="mi">10</span> <span class="p">}</span>
</code></pre></div></div>

<p>Though a little more complex than its counterpart in the aforementioned String
Localization refactoring, this implementation is self-explaining too. Lines 3
to 4 check the kind of the given range, which has to be a single expression
to proceed with the extraction. Lines 5 to 7 ensure the extracted expression has
a well-formed type. Further conditions that need to be checked are omitted in
the example for now. Interested readers can refer to <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp">Refactoring.cpp</a> for
more details. For the code change part, we can use the same <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L344">ResolvedRangeInfo</a> instance
to emit textual edits:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kt">bool</span> <span class="n">RefactoringActionExtractExprBase</span><span class="o">::</span><span class="n">performChange</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>    <span class="n">llvm</span><span class="o">::</span><span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="n">DeclBuffer</span><span class="p">;</span>
<span class="mi">3</span>    <span class="n">llvm</span><span class="o">::</span><span class="n">raw_svector_ostream</span> <span class="n">OS</span><span class="p">(</span><span class="n">DeclBuffer</span><span class="p">);</span>
<span class="mi">4</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">tok</span><span class="o">::</span><span class="n">kw_let</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="mi">5</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">PreferredName</span><span class="p">;</span>
<span class="mi">6</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">TyBuffer</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span>  <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">RangeInfo</span><span class="p">.</span><span class="n">ContentRange</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="mi">7</span>    <span class="n">Expr</span> <span class="o">*</span><span class="n">E</span> <span class="o">=</span> <span class="n">RangeInfo</span><span class="p">.</span><span class="n">ContainedNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">*&gt;</span><span class="p">();</span>
<span class="mi">8</span>    <span class="n">EditConsumer</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span> <span class="n">InsertLoc</span><span class="p">,</span> <span class="n">DeclBuffer</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
<span class="mi">9</span>    <span class="n">EditConsumer</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span>
<span class="mi">10</span>                       <span class="n">Lexer</span><span class="o">::</span><span class="n">getCharSourceRangeFromSourceRange</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getSourceRange</span><span class="p">()),</span>
<span class="mi">11</span>                       <span class="n">PreferredName</span><span class="p">)</span>
<span class="mi">12</span>   <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Return true if code change aborted.</span>
<span class="mi">13</span> <span class="p">}</span>
</code></pre></div></div>

<p>Lines 2 to 6 construct the declaration of a local variable with the initialized
value of the expression under extraction, e.g. <code class="language-plaintext highlighter-rouge">let extractedExpr = foo()</code>. Line
8 inserts the declaration at the proper source location in the local context, and
Line 9 replaces the original occurrence of the expression with a reference to
the newly declared variable. As demonstrated by the code example, within the
function body of <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L599">performChange</a>, we can access not only the original
<a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/IDE/Utils.h#L344">ResolvedRangeInfo</a> for the user’s selection, but also other important utilities such
as the edit consumer and source manager, making the implementation more convenient.</p>

<h2 id="diagnostics">Diagnostics</h2>
<p>A refactoring action may need to be aborted during automated code change for various reasons.
When this happens, a refactoring implementation can communicate via diagnostics the cause of such failures to the user.
Refactoring diagnostics employ the same mechanism as the compiler itself.
Taking rename refactoring as an example, we would like to issue
an error message if the given new name is an invalid Swift identifier. To do so,
we first need to declare the following entry for the diagnostics in
<a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/include/swift/AST/DiagnosticsRefactoring.def">DiagnosticsRefactoring.def</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">ERROR</span><span class="p">(</span><span class="n">invalid_name</span><span class="p">,</span> <span class="n">none</span><span class="p">,</span> <span class="s">"'%0' is not a valid name"</span><span class="p">,</span> <span class="p">(</span><span class="n">StringRef</span><span class="p">))</span>
</code></pre></div></div>

<p>After declaring it, we can use the diagnostic in either <a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L646">isApplicable</a> or
<a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp#L599">performChange</a>. For <em>Local Rename</em> refactoring, emitting the diagnostic in
<a href="https://github.com/apple/swift/blob/60a91bb7360dde5ce9531889e0ed10a2edbc961a/lib/IDE/Refactoring.cpp">Refactoring.cpp</a> would look something like:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kt">bool</span> <span class="n">RefactoringActionLocalRename</span><span class="o">::</span><span class="n">performChange</span><span class="p">()</span> <span class="p">{</span>
   <span class="p">...</span>
<span class="mi">2</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DeclNameViewer</span><span class="p">(</span><span class="n">PreferredName</span><span class="p">).</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
<span class="mi">3</span>      <span class="n">DiagEngine</span><span class="p">.</span><span class="n">diagnose</span><span class="p">(</span><span class="n">SourceLoc</span><span class="p">(),</span> <span class="n">diag</span><span class="o">::</span><span class="n">invalid_name</span><span class="p">,</span> <span class="n">PreferredName</span><span class="p">);</span>
<span class="mi">4</span>      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Return true if code change aborted.</span>
<span class="mi">5</span>    <span class="p">}</span>
   <span class="p">...</span>
<span class="mi">6</span>  <span class="p">}</span>
</code></pre></div></div>

<h2 id="testing">Testing</h2>

<p>Corresponding to the two steps in implementing a new
refactoring action, we need to test that:</p>

<ol>
  <li>The contextually available refactorings are
populated properly.</li>
  <li>The automated code change updates the user’s codebase correctly.</li>
</ol>

<p>These two parts are both tested using the <a href="https://github.com/apple/swift/tree/60a91bb7360dde5ce9531889e0ed10a2edbc961a/tools/swift-refactor">swift-refactor</a> command line utility which
is built alongside the compiler.</p>

<h4 id="contextual-refactoring-test">Contextual Refactoring Test</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="n">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>    <span class="n">print</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">)</span>
<span class="mi">3</span>  <span class="p">}</span>
<span class="mi">4</span>  <span class="c1">// RUN: %refactor -source-filename %s -pos=2:14 | %FileCheck %s -check-prefix=CHECK-LOCALIZE-STRING</span>
<span class="mi">5</span>  <span class="c1">// CHECK-LOCALIZE-STRING: Localize String</span>
</code></pre></div></div>

<p>Let’s again take String Localization as an example. The above code
snippet is a test for contextual refactoring actions.
Similar tests can be found in <a href="https://github.com/apple/swift/tree/master/test/refactoring/RefactoringKind">test/refactoring/RefactoringKind/</a>.</p>

<p>Let’s take a look at the <code class="language-plaintext highlighter-rouge">RUN</code> line in more detail, starting with the use of the <code class="language-plaintext highlighter-rouge">%refactor</code> utility:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">refactor</span> <span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">filename</span> <span class="o">%</span><span class="n">s</span> <span class="o">-</span><span class="n">pos</span><span class="o">=</span><span class="mi">2</span><span class="o">:</span><span class="mi">14</span> <span class="o">|</span> <span class="o">%</span><span class="n">FileCheck</span> <span class="o">%</span><span class="n">s</span> <span class="o">-</span><span class="n">check</span><span class="o">-</span><span class="n">prefix</span><span class="o">=</span><span class="n">CHECK</span><span class="o">-</span><span class="n">LOCALIZE</span><span class="o">-</span><span class="n">STRING</span>
</code></pre></div></div>

<p>This line will dump the display names for all applicable refactorings when a user points the cursor to the string literal “Hello World!”.
<code class="language-plaintext highlighter-rouge">%refactor</code> is an alias that gets substituted by the test runner to give the full path to <code class="language-plaintext highlighter-rouge">swift-refactor</code> when the tests get run.
<code class="language-plaintext highlighter-rouge">-pos</code> gives the cursor position where contextual refactoring actions should be pulled from. Since
<code class="language-plaintext highlighter-rouge">String Localization</code> refactoring is cursor-based, specifying <code class="language-plaintext highlighter-rouge">-pos</code> alone will be
sufficient. To test range-based refactorings, we need to specify
<code class="language-plaintext highlighter-rouge">-end-pos</code> to indicate the end location of the refactoring target as well. All positions are
in the format of <code class="language-plaintext highlighter-rouge">line:column</code>.</p>

<p>To make sure the output of the tool is the expected one, we use the <code class="language-plaintext highlighter-rouge">%FileCheck</code> utility:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">FileCheck</span> <span class="o">%</span><span class="n">s</span> <span class="o">-</span><span class="n">check</span><span class="o">-</span><span class="n">prefix</span><span class="o">=</span><span class="n">CHECK</span><span class="o">-</span><span class="n">LOCALIZE</span><span class="o">-</span><span class="n">STRING</span>
</code></pre></div></div>

<p>This will check the output text from <code class="language-plaintext highlighter-rouge">%refactor</code>
against all following lines with prefix <code class="language-plaintext highlighter-rouge">CHECK-LOCALIZE-STRING</code>. In this case, it will
check whether the available refactorings include <code class="language-plaintext highlighter-rouge">Localize String</code>. In addition to
testing that we show the right actions at the right cursor positions, we also need to
test available refactorings are not wrongly populated in situations like string literals
with interpolation.</p>

<h4 id="code-transformation-test">Code Transformation Test</h4>

<p>We should also test that when applying the refactoring, the automated code
change matches our expectations. As a preparation, we need to teach <a href="https://github.com/apple/swift/tree/60a91bb7360dde5ce9531889e0ed10a2edbc961a/tools/swift-refactor">swift-refactor</a>
a refactoring kind flag to specify the action we are testing with. To achieve this,
the following entry is added in <a href="https://github.com/apple/swift/blob/master/tools/swift-refactor/swift-refactor.cpp">swift-refactor.cpp</a>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">clEnumValN</span><span class="p">(</span><span class="n">RefactoringKind</span><span class="o">::</span><span class="n">LocalizeString</span><span class="p">,</span> <span class="s">"localize-string"</span><span class="p">,</span> <span class="s">"Perform String Localization refactoring"</span><span class="p">),</span>
</code></pre></div></div>

<p>With such an entry, <a href="https://github.com/apple/swift/tree/60a91bb7360dde5ce9531889e0ed10a2edbc961a/tools/swift-refactor">swift-refactor</a> can test the code transformation part of
String Localization specifically. A typical code transformation test consists of two parts:</p>

<ol>
  <li>The code snippet before refactoring.</li>
  <li>The expected output after transformation.</li>
</ol>

<p>The test performs the designated refactoring in (1) and compares the result
with (2). It passes if the two are identical, otherwise the test fails.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>    <span class="nf">print</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">)</span>
<span class="mi">3</span>  <span class="p">}</span>
<span class="mi">4</span>  <span class="c1">// RUN: rm -rf %t.result &amp;&amp; mkdir -p %t.result</span>
<span class="mi">5</span>  <span class="c1">// RUN: %refactor -localize-string -source-filename %s -pos=2:14 &gt; %t.result/localized.swift</span>
<span class="mi">6</span>  <span class="c1">// RUN: diff -u %S/Iutputs/localized.swift.expected %t.result/localized.swift</span>
</code></pre></div></div>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>  <span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">2</span>    <span class="nf">print</span><span class="p">(</span><span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">""</span><span class="p">))</span>
<span class="mi">3</span>  <span class="p">}</span>
</code></pre></div></div>

<p>The above two code snippets comprise a meaningful code transformation test.
Line 4 prepares a temporary source directory
for the code resulting from the refactoring; using the newly added <code class="language-plaintext highlighter-rouge">-localize-string</code>,
 Line 5 performs the refactoring code change at the start position of <code class="language-plaintext highlighter-rouge">"Hello World!"</code> and
dumps the result to the temporary directory; finally, Line 6 compares the result
with the expected output illustrated in the second code example.</p>

<h2 id="integrating-with-xcode">Integrating with Xcode</h2>
<p>After implementing all of above pieces in the Swift codebase, we
are ready to test/use the newly added refactoring in Xcode by integrating with
a locally-built open source toolchain.</p>

<ol>
  <li>
    <p>Run <a href="https://github.com/apple/swift/blob/master/utils/build-toolchain">build-toolchain</a>
to build the open source toolchain locally.</p>
  </li>
  <li>
    <p>Untar and copy the toolchain to <code class="language-plaintext highlighter-rouge">/Library/Developer/Toolchains/</code>.</p>
  </li>
  <li>
    <p>Specify the local toolchain for Xcode’s use via <code class="language-plaintext highlighter-rouge">Xcode-&gt;Toolchains</code>, like the
following figure illustrates.</p>
  </li>
</ol>

<p><img src="https://swift.org/assets/images/local-refactoring/Toolchain.png" alt="Specify Toolchain" /></p>

<h2 id="potential-local-refactoring-ideas">Potential Local Refactoring Ideas</h2>
<p>This post just touches on some of the things that are now possible to implement in the new refactoring engine.
If you are excited about extending the refactoring engine to implement additional transformations,
Swift’s <a href="https://bugs.swift.org">issue database</a> contains <a href="https://bugs.swift.org/issues/?jql=labels%3DStarterProposal%20AND%20labels%3DRefactoring%20AND%20resolution%3DUnresolved">several ideas of refactoring transformations</a> awaiting implementations.
If you’d like to propose new refactoring ideas, filing a task in Swift’s <a href="https://bugs.swift.org">issue database</a> with
label <code class="language-plaintext highlighter-rouge">Refactoring</code> will be sufficient.</p>

<p>For further help with implementing refactoring transformations, please see the <a href="https://github.com/apple/swift/blob/master/docs/refactoring/SwiftLocalRefactoring.md">documentation</a> or feel free to ask questions on the <a href="https://lists.swift.org/mailman/listinfo/swift-dev">swift-dev</a> mailing list.</p>



  
  <footer>
    <nav>
      
      <a href="/blog/swift-package-manager-manifest-api-redesign/" rel="prev" title="Previous: Swift Package Manager Manifest API Redesign">Swift Package Manager Manifest API Redesign</a>
      

      
      <a href="/blog/swift-4.0-released/" rel="next" title="Next: Swift 4.0 Released!">Swift 4.0 Released!</a>
      
    </nav>
  </footer>
  
</article>
</main>



<footer role="contentinfo">
  <div class="footer-content">
    
  <p>Except where otherwise noted, all content on this blog is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.</p>

    <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
    <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
    <p class="privacy">
      <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
      <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
    </p>
  </div>
  <div class="footer-other">
    <form
      class="color-scheme-toggle"
      role="radiogroup"
      tabindex="0"
      id="color-scheme-toggle"
    >
      <legend class="visuallyhidden">Color scheme preference</legend>
      <label for="scheme-light">
        <input id="scheme-light" type="radio" name="color-scheme-preference" value="light">
        <span class="color-scheme-toggle-label">Light</span>
      </label>
      <label for="scheme-dark">
        <input id="scheme-dark" type="radio" name="color-scheme-preference" value="dark">
        <span class="color-scheme-toggle-label">Dark</span>
      </label>
      <label for="scheme-auto" id="scheme-auto-wrapper">
        <input id="scheme-auto" type="radio" name="color-scheme-preference" value="auto">
        <span class="color-scheme-toggle-label">Auto</span>
      </label>
    </form>
    <aside>
      <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter"></i></a>
      <a href="/atom.xml" title="Subscribe to Site Updates"><i class="feed"></i></a>
    </aside>
  </div>
</footer>


<script src="/assets/javascripts/application.js"></script>
<!-- metrics -->
<script>
    /* RSID: */
    var s_account="awdswiftorg"
</script>
<script src="https://developer.apple.com/assets/metrics/scripts/analytics.js"></script>
<script>
    s.pageName= AC && AC.Tracking && AC.Tracking.pageName();

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)
</script>
<!-- /metrics -->
</body>
</html>
