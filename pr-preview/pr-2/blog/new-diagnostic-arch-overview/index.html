<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Swift.org - New Diagnostic Architecture Overview</title>
  <meta name="author" content="Apple Inc." />
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <link rel="license" href="/LICENSE.txt" />
  <link rel="stylesheet" media="all" href="/assets/stylesheets/application.css" />
  <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
  <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" />
  

  
  <link rel="canonical" href="https://swift.org/blog/new-diagnostic-arch-overview/" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@SwiftLang" />
  
  <meta name="twitter:title" content="New Diagnostic Architecture Overview" />
  <meta name="twitter:description" content="Diagnostics play a very important role in a programming language experience. It’s vital for developer productivity that the compiler can produce proper guidance in any situation, especially incomplete or invalid code.
" />
  

  <meta property="og:site_name" content="Swift.org" />
  <meta property="og:image" content="https://swift.org/apple-touch-icon-180x180.png" />
  
  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="New Diagnostic Architecture Overview" />
  <meta property="og:url" content="https://swift.org/blog/new-diagnostic-arch-overview/" />
  <meta property="og:description" content="Diagnostics play a very important role in a programming language experience. It’s vital for developer productivity that the compiler can produce proper guidance in any situation, especially incomplete or invalid code.
" />
  <meta property="article:published_time" content="2019-10-17T06:00:00-04:00" />
  <meta property="article:modified_time" content="2022-06-14T07:08:53-04:00" />
  
</head>

<body>
<script src="/assets/javascripts/color-scheme-toggle.js"></script>
<nav role="navigation">
  <div class="nav-menu-container">
    <header class="menu-item logo-container" role="banner">
      <h1 id="logo">
        <a href="/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>
    <div id="menu-toggle" class="menu-item menu-toggle open"></div>
  </div>

  <div class="list-items">
    
    
    <ul>
      
      
      <li>
      
        <a href="/about/">About Swift</a>
        
      </li>
      
      
      <li>
      
        <a href="/blog/">Blog</a>
        
      </li>
      
      
      <li>
      
        <a href="/getting-started/">Getting Started</a>
        
      </li>
      
      
      <li>
      
        <a href="/download/">Download</a>
        
      </li>
      
      
      <li>
      
        <a href="/platform-support/">Platform Support</a>
        
      </li>
      
      
      <li>
      
        <a href="/documentation/">Documentation</a>
        
      </li>
      
    </ul>
    
    
    <h2>Community</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/community/">Community Overview</a>
        
      </li>
      
      
      <li>
      
        <a href="/diversity/">Diversity</a>
        
      </li>
      
      
      <li>
      
        <a href="/mentorship/">Mentorship</a>
        
      </li>
      
      
      <li>
      
        <a href="/contributing/">Contributing</a>
        
      </li>
      
      
      <li>
      
        <a href="/code-of-conduct/">Code of Conduct</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Development</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/source-code/">Source Code</a>
        
      </li>
      
      
      <li>
      
        <a href="/continuous-integration/">Continuous Integration</a>
        
      </li>
      
      
      <li>
      
        <a href="/source-compatibility/">Source Compatibility</a>
        
      </li>
      
      
      <li>
      
        <a href="/support/security.html">Security</a>
        
      </li>
      
    </ul>
    
    
    <h2>Open Source Efforts</h2>
    
    <ul>
      
      
      <li>
      
        <a href="/swift-compiler/">Swift Compiler</a>
        
      </li>
      
      
      <li>
      
        <a href="/standard-library/">Standard Library</a>
        
      </li>
      
      
      <li>
      
        <a href="/package-manager/">Package Manager</a>
        
      </li>
      
      
      <li>
      
        <a href="/core-libraries/">Core Libraries</a>
        
      </li>
      
      
      <li>
      
        <a href="/lldb/">REPL, Debugger & Playgrounds</a>
        
      </li>
      
      
      <li>
      
        <a href="/server/">Swift on Server</a>
        
      </li>
      
      
      <li>
      
        <a href="/website/">Swift.org website</a>
        
      </li>
      
    </ul>
    
  </div>
</nav>

<main role="main">
<article class="post">
  <header>
    <h1>New Diagnostic Architecture Overview</h1>

    <time pubdate datetime="2019-10-17T06:00:00-04:00">October 17, 2019</time>
    
    
    
      <div class="byline">
        

        <span class="author">
          
            <a href="https://github.com/xedin/" rel="nofollow" title="Pavel Yaskevich (@xedin) on GitHub">Pavel Yaskevich</a>
          
        </span>
      </div>
      
    
    
  </header>

  <p>Diagnostics play a very important role in a programming language experience. It’s vital for developer productivity that the compiler can produce proper guidance in any situation, especially incomplete or invalid code.</p>

<p>In this blog post we would like to share a couple of important updates on improvements to diagnostics being worked on for the upcoming Swift 5.2 release. This includes a new strategy for diagnosing failures in the compiler, originally introduced as part of Swift 5.1 release, that yields some exciting new results and improved error messages.</p>

<h2 id="the-challenge">The Challenge</h2>

<p>Swift is a very expressive language with a rich type system that has many features like class inheritance, protocol conformances, generics, and overloading. Though we as programmers try our best to write well-formed programs, sometimes we need a little help. Luckily, the compiler knows exactly what Swift code is valid and invalid. The problem is how best to tell you what has gone wrong, where it happened, and how you can fix it.</p>

<p>Many parts of the compiler ensure the correctness of your program, but the focus of this work has been improving the <em>type checker</em>. The Swift type checker enforces rules about how types are used in source code, and it is responsible for letting you know when those rules are violated.</p>

<p>For example, the following code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">S</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">_</span> <span class="o">=</span> <span class="kt">S</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">([</span><span class="n">i</span><span class="o">!</span><span class="p">])</span>
</code></pre></div></div>

<p>Produces the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: type of expression is ambiguous without more context
</code></pre></div></div>

<p>While this diagnostic points out a genuine error, it’s not helpful because it is not specific or actionable. This is because the old type checker used to <em>guess</em> the exact location of an error. This worked in many cases, but there were still numerous kinds of programming mistakes that users would write which it could not accurately identify. In order to address this, a new diagnostic infrastructure is in the works. Rather than guessing where an error occurs, the type checker attempts to “fix” problems right at the point where they are encountered, while remembering the fixes it has applied. This not only allows the type checker to pinpoint errors in more kinds of programs, it also allows it to surface more failures where previously it would simply stop after reporting the first error.</p>

<h2 id="type-inference-overview">Type Inference Overview</h2>

<p>Since the new diagnostic infrastructure is tightly coupled with the type checker, we have to take a brief detour and talk about type inference. Note that this is a brief introduction; for more details please refer to the <a href="https://github.com/apple/swift/blob/master/docs/TypeChecker.rst">compiler’s documentation on the type checker</a>.</p>

<p>Swift implements bi-directional type inference using a constraint-based type checker that is reminiscent of the classical <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner</a> type inference <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#An_inference_algorithm">algorithm</a>:</p>

<ul>
  <li>The type checker converts the source code into a <em>constraint system</em>, which represents relationships among the types in the code.</li>
  <li>A type relationship is expressed via a <em>type constraint</em>, which either places a requirement on a single type (e.g., it is an integer literal type) or relates two types (e.g., one is a convertible to the other).</li>
  <li>The types described in constraints can be any type in the Swift type system, including tuple types, function types, enum/struct/class types, protocol types, and generic types. Additionally, a type can be a <em>type variable</em> denoted as <code class="language-plaintext highlighter-rouge">$&lt;name&gt;</code>.</li>
  <li>Type variables can be used in place of any other type, e.g., a tuple type <code class="language-plaintext highlighter-rouge">($Foo, Int)</code> involving the type variable <code class="language-plaintext highlighter-rouge">$Foo</code>.</li>
</ul>

<p>The Constraint System performs three steps:</p>

<ol>
  <li><a href="https://github.com/apple/swift/blob/cfae1a3b16e60d6b17db95a681131f88cee65f3b/docs/TypeChecker.rst#constraint-generation">Constraint Generation</a></li>
  <li><a href="https://github.com/apple/swift/blob/cfae1a3b16e60d6b17db95a681131f88cee65f3b/docs/TypeChecker.rst#constraint-solving">Constraint Solving</a></li>
  <li><a href="https://github.com/apple/swift/blob/cfae1a3b16e60d6b17db95a681131f88cee65f3b/docs/TypeChecker.rst#solution-application">Solution Application</a></li>
</ol>

<p>For diagnostics, the only interesting stages are Constraint Generation and Solving.</p>

<p>Given an input expression (and sometimes additional contextual information), the constraint solver generates:</p>

<ol>
  <li>A set of type variables that represent an abstract type of each sub-expression</li>
  <li>A set of type constraints that describe the relationships between those type variables</li>
</ol>

<p>The most common type of constraint is a <em>binary constraint</em>, which relates two types and is denoted as:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type1 <span class="nt">&lt;constraint</span> <span class="err">kind</span><span class="nt">&gt;</span> type2
</code></pre></div></div>

<p>Commonly used binary constraints are:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">$X &lt;bind to&gt; Y</code> - Binds type variable <code class="language-plaintext highlighter-rouge">$X</code> to a fixed type <code class="language-plaintext highlighter-rouge">Y</code></li>
  <li><code class="language-plaintext highlighter-rouge">X &lt;convertible to&gt; Y</code> - A conversion constraint requires that the first type <code class="language-plaintext highlighter-rouge">X</code> be convertible to the second <code class="language-plaintext highlighter-rouge">Y</code>, which includes subtyping and equality</li>
  <li><code class="language-plaintext highlighter-rouge">X &lt;conforms to&gt; Y</code> - Specifies that the first type <code class="language-plaintext highlighter-rouge">X</code> must conform to the protocol <code class="language-plaintext highlighter-rouge">Y</code></li>
  <li><code class="language-plaintext highlighter-rouge">(Arg1, Arg2, ...) → Result &lt;applicable to&gt; $Function</code> - An “applicable function” constraint requires that both types are function types with the same input and output types</li>
</ol>

<p>Once constraint generation is complete, the solver attempts to assign concrete types to each of the type variables in the constraint system and form a solution that satisfies all of the constraints.</p>

<p>Let’s consider the following example function:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="n">_</span> <span class="nv">str</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">str</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For a human, it becomes apparent pretty quickly that there is a problem with the expression <code class="language-plaintext highlighter-rouge">str + 1</code> and where that problem is located, but the inference engine can only rely on a constraint simplification algorithm to determine what is wrong.</p>

<p>As we have established previously, the constraint solver starts by generating constraints (see <a href="https://github.com/apple/swift/blob/cfae1a3b16e60d6b17db95a681131f88cee65f3b/docs/TypeChecker.rst#constraint-generation">Constraint Generation</a> stage) for <code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">+</code>. Each distinct sub-element of the input expression, like <code class="language-plaintext highlighter-rouge">str</code>, is represented either by:</p>

<ol>
  <li>a concrete type (known ahead of time)</li>
  <li>a type variable denoted with <code class="language-plaintext highlighter-rouge">$&lt;name&gt;</code> which can assume any type that satisfies the constraints associated with it.</li>
</ol>

<p>After the <a href="https://github.com/apple/swift/blob/cfae1a3b16e60d6b17db95a681131f88cee65f3b/docs/TypeChecker.rst#constraint-generation">Constraint Generation</a> stage completes, the constraint system for the expression <code class="language-plaintext highlighter-rouge">str + 1</code> will have a combination of type variables and constraints.  Let’s look at those now.</p>

<h3 id="type-variables">Type Variables</h3>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$Str</code> represents the type of variable <code class="language-plaintext highlighter-rouge">str</code>, which is the first argument in the call to <code class="language-plaintext highlighter-rouge">+</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$One</code> represents the type of literal <code class="language-plaintext highlighter-rouge">1</code>, which is the second argument in the call to <code class="language-plaintext highlighter-rouge">+</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$Result</code> represents the result type of the call to operator <code class="language-plaintext highlighter-rouge">+</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">$Plus</code> represents the type of the operator <code class="language-plaintext highlighter-rouge">+</code> itself, which is a set of possible overload choices to attempt.</p>
  </li>
</ul>

<h3 id="constraints">Constraints</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Str &lt;bind to&gt; String</code>
    <ul>
      <li>Argument <code class="language-plaintext highlighter-rouge">str</code> has a fixed <a href="https://developer.apple.com/documentation/swift/string">String</a> type.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">$One &lt;conforms to&gt; ExpressibleByIntegerLiteral</code>
    <ul>
      <li>Since integer literals like <code class="language-plaintext highlighter-rouge">1</code> in Swift could assume any type conforming to the <a href="https://developer.apple.com/documentation/swift/expressiblebyintegerliteral">ExpressibleByIntegerLiteral</a> protocol (e.g. <code class="language-plaintext highlighter-rouge">Int</code> or <code class="language-plaintext highlighter-rouge">Double</code>), the solver can only rely on that information at the beginning.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">$Plus &lt;bind to&gt; disjunction((String, String) -&gt; String, (Int, Int) -&gt; Int, ...)</code>
    <ul>
      <li>Operator <code class="language-plaintext highlighter-rouge">+</code> forms a <a href="https://en.wikipedia.org/wiki/Disjoint_sets">disjoint set</a> of choices, where each element represents the type of an individual overload.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">($Str, $One) -&gt; $Result &lt;applicable to&gt; $Plus</code>
    <ul>
      <li>The type of <code class="language-plaintext highlighter-rouge">$Result</code> is not yet known; it will be determined by testing each overload of <code class="language-plaintext highlighter-rouge">$Plus</code> with argument tuple <code class="language-plaintext highlighter-rouge">($Str, $One)</code>.</li>
    </ul>
  </li>
</ul>

<p>Note that all constraints and type variables are linked with particular locations in the input expression:</p>

<p><img src="/assets/images/diagnostics-arch-blog/constraints-linked-with-exprs.png" alt="Constraints Linked To Expressions" /></p>

<p>The inference algorithm attempts to find suitable types for all type variables in the constraint system and test them against associated constraints. In our example, <code class="language-plaintext highlighter-rouge">$One</code> could get a type of <code class="language-plaintext highlighter-rouge">Int</code> or <code class="language-plaintext highlighter-rouge">Double</code> because both of these types satisfy the <code class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code> protocol conformance requirement. However, simply enumerating through all of the possible types for each of the “empty” type variables in the constraint system is very inefficient since there could be <strong>many</strong> types to try when a particular type variable is under-constrained. For example, <code class="language-plaintext highlighter-rouge">$Result</code> has no restrictions, so it could potentially assume any type. To work around this problem, the constraint solver first tries disjunction choices, which allows the solver to narrow down the set of possible types for each type variable involved. In the case of <code class="language-plaintext highlighter-rouge">$Result</code>, this brings the number of possible types down to only the result types associated with overloads choices of <code class="language-plaintext highlighter-rouge">$Plus</code> instead of all possible types.</p>

<p>Now, it’s time to run the inference algorithm to determine types for <code class="language-plaintext highlighter-rouge">$One</code> and <code class="language-plaintext highlighter-rouge">$Result</code>.</p>

<h3 id="a-single-round-of-inference-algorithm-execution">A Single Round of Inference Algorithm Execution:</h3>

<ol>
  <li>
    <p>Let’s start by binding <code class="language-plaintext highlighter-rouge">$Plus</code> to its first disjunction choice of <code class="language-plaintext highlighter-rouge">(String, String) -&gt; String</code></p>
  </li>
  <li>
    <p>Now the <code class="language-plaintext highlighter-rouge">applicable to</code> constraint could be tested because <code class="language-plaintext highlighter-rouge">$Plus</code> has been bound to a concrete type. Simplification of the <code class="language-plaintext highlighter-rouge">($Str, $One) -&gt; $Result &lt;applicable to&gt; $Plus</code> constraint ends up matching two function types <code class="language-plaintext highlighter-rouge">($Str, $One) -&gt; $Result</code> and <code class="language-plaintext highlighter-rouge">(String, String) -&gt; String</code> which proceeds as follows:</p>

    <ul>
      <li>Add a new conversion constraint to match argument 0 to parameter 0 - <code class="language-plaintext highlighter-rouge">$Str &lt;convertible to&gt; String</code></li>
      <li>Add a new conversion constraint to match argument 1 to parameter 1 - <code class="language-plaintext highlighter-rouge">$One &lt;convertible to&gt; String</code></li>
      <li>Equate <code class="language-plaintext highlighter-rouge">$Result</code> to <code class="language-plaintext highlighter-rouge">String</code> since result types have to be equal</li>
    </ul>
  </li>
  <li>
    <p>Some of the newly generated constraints could be immediately tested/simplified e.g.</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">$Str &lt;convertible to&gt; String</code> is <code class="language-plaintext highlighter-rouge">true</code> because <code class="language-plaintext highlighter-rouge">$Str</code> already has a fixed type of <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">String</code> is convertible to itself</li>
      <li><code class="language-plaintext highlighter-rouge">$Result</code> could be assigned a type of <code class="language-plaintext highlighter-rouge">String</code> based on equality constraint</li>
    </ul>
  </li>
  <li>
    <p>At this point the only remaining constraints are:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">$One &lt;convertible to&gt; String</code></li>
      <li><code class="language-plaintext highlighter-rouge">$One &lt;conforms to&gt; ExpressibleByIntegerLiteral</code></li>
    </ul>
  </li>
  <li>
    <p>The possible types for <code class="language-plaintext highlighter-rouge">$One</code> are <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Double</code>, and <code class="language-plaintext highlighter-rouge">String</code>. This is interesting, because none of these possible types satisfy <strong>all</strong> of the remaining constraints; <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Double</code> both are not convertible to <code class="language-plaintext highlighter-rouge">String</code>, and <code class="language-plaintext highlighter-rouge">String</code> does not conform to <code class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code> protocol</p>
  </li>
  <li>
    <p>After attempting all possible types for <code class="language-plaintext highlighter-rouge">$One</code>, the solver stops and considers the current set of types and overload choices a failure. The solver then backtracks and attempts the next disjunction choice for <code class="language-plaintext highlighter-rouge">$Plus</code>.</p>
  </li>
</ol>

<p>We can see that the error location would be determined by the solver as it executes inference algorithm. Since none of the possible types match for <code class="language-plaintext highlighter-rouge">$One</code> it should be considered an error location (because it cannot be bound to any type). Complex expressions could have many more than one such location because existing errors result in new ones as the inference algorithm progresses. To narrow down error locations in situations like that, the solver would only pick solutions with the smallest possible number thereof.</p>

<p>At this point it’s more or less clear how error locations are identified, but it’s not yet obvious how to help the solver make forward progress in such scenarios so it can derive a complete solution.</p>

<h2 id="the-approach">The Approach</h2>

<p>The new diagnostic infrastructure employs what we are going to call a <em>constraint fix</em> to try and resolve inconsistent situations where the solver gets stuck with no other types to attempt. The fix for our example is to ignore that <code class="language-plaintext highlighter-rouge">String</code> doesn’t conform to the <code class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code> protocol. The purpose of a fix is to be able to capture all useful information about the error location from the solver and use that later for diagnostics. That is the main difference between current and new approaches. The former would try to <em>guess</em> where the error is located, where the new approach has a symbiotic relationship with the solver which provides all of the error locations to it.</p>

<p>As we noted before, all of the type variables and constraints carry information about their relationship to the sub-expression they have originated from. Such a relation combined with type information makes it straightforward to provide tailored diagnostics and fix-its to all of the problems diagnosed via the new diagnostic framework.</p>

<p>In our example, it has been determined that the type variable <code class="language-plaintext highlighter-rouge">$One</code> is an error location, so the diagnostic can examine how <code class="language-plaintext highlighter-rouge">$One</code> is used in the input expression: <code class="language-plaintext highlighter-rouge">$One</code> represents an argument at position #2 in call to operator <code class="language-plaintext highlighter-rouge">+</code>, and it’s known that the problem is related to the fact that <code class="language-plaintext highlighter-rouge">String</code> doesn’t conform to <code class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code> protocol. Based on all this information it’s possible to form either of the two following diagnostics:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: binary operator '+' cannot be applied to arguments 'String' and 'Int'
</code></pre></div></div>

<p>with a note about the second argument not conforming to the <code class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code> protocol, or the simpler:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: argument type 'String' does not conform to 'ExpressibleByIntegerLiteral'
</code></pre></div></div>

<p>with the diagnostic referring to the second argument.</p>

<p>We picked the first alternative and produce a diagnostic about the operator and a note for each partially matching overload choice. Let’s take a closer look at the inner workings of the described approach.</p>

<h2 id="anatomy-of-a-diagnostic">Anatomy of a Diagnostic</h2>

<p>When a constraint failure is detected, a <em>constraint fix</em> is created that captures information about a failure:</p>

<ul>
  <li>The kind of failure that occurred</li>
  <li>The location in the source code where the failure came from</li>
  <li>The types and declarations involved in the failure</li>
</ul>

<p>The constraint solver accumulates these fixes. Once it arrives at a solution, it looks at the fixes that were part of a solution and produces actionable errors or warnings. Let’s take a look at how this all works together. Consider the following example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">var</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The problem here is related to an argument <code class="language-plaintext highlighter-rouge">x</code> which cannot be passed as an argument to <code class="language-plaintext highlighter-rouge">inout</code> parameter without an explicit <code class="language-plaintext highlighter-rouge">&amp;</code>.</p>

<p>Let’s now look at the type variables and constraints for this constraint system.</p>

<h3 id="type-variables-1">Type Variables</h3>

<p>There are three type variables:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$X := Int
$Foo := (inout Int) -&gt; Void
$Result
</code></pre></div></div>

<h3 id="constraints-1">Constraints</h3>

<p>The three type variables have the following constraint:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>($X) -&gt; $Result &lt;applicable to&gt; $Foo
</code></pre></div></div>

<p>The inference algorithm is going to try and match <code class="language-plaintext highlighter-rouge">($X) -&gt; $Result</code> to <code class="language-plaintext highlighter-rouge">(inout Int) -&gt; Void</code>, which results in the following new constraints:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Int &lt;convertible to&gt; inout Int
$Result &lt;equal to&gt; Void
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Int</code> cannot be converted into <code class="language-plaintext highlighter-rouge">inout Int</code>, so the constraint solver records the failure as a <a href="https://github.com/apple/swift/blob/0086eb05af5d6e1a0ce2e9d6d788c592a6b5216f/lib/Sema/CSFix.h#L531L543">missing <code class="language-plaintext highlighter-rouge">&amp;</code></a> and ignores the <code class="language-plaintext highlighter-rouge">&lt;convertible to&gt;</code> constraint.</p>

<p>With that constraint ignored, the remainder of the constraint system can be solved. Then the type checker looks at the recorded fixes and <a href="https://github.com/apple/swift/blob/0086eb05af5d6e1a0ce2e9d6d788c592a6b5216f/lib/Sema/CSDiagnostics.cpp#L993L1010">emits an error</a> that describes the problem (a missing <code class="language-plaintext highlighter-rouge">&amp;</code>) along with a Fix-It to insert the <code class="language-plaintext highlighter-rouge">&amp;</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: passing value of type 'Int' to an inout parameter requires explicit '&amp;'
foo(x)
    ^
    &amp;
</code></pre></div></div>

<p>This example had a single type error in it, but this diagnostics architecture can also account for multiple distinct type errors in the code. Consider a slightly more complicated example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">bar</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">var</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">)</span>
</code></pre></div></div>

<p>While solving this constraint system, the type checker will again record a failure for the missing <code class="language-plaintext highlighter-rouge">&amp;</code> on the first argument to <code class="language-plaintext highlighter-rouge">foo</code>. Additionally, it will record a failure for the missing argument label <code class="language-plaintext highlighter-rouge">bar</code>. Once both failures have been recorded, the remainder of the constraint system is solved. The type checker then produces errors (with Fix-Its) for the two problems that need to be addressed to fix this code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: passing value of type 'Int' to an inout parameter requires explicit '&amp;'
foo(x)
   ^
    &amp;
error: missing argument label 'bar:' in call
foo(x, "bar")
      ^
       bar: 
</code></pre></div></div>

<p>Recording every specific failure and then continuing on to solve the remaining constraint system implies that addressing those failures will produce a well-typed solution. That allows the type checker to produce actionable diagnostics, often with fixes, that lead the developer toward correct code.</p>

<h2 id="examples-of-improved-diagnostics">Examples Of Improved Diagnostics</h2>

<h3 id="missing-labels">Missing label(s)</h3>

<p>Consider the following invalid code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">answer</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"a"</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">answer</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"b"</span> <span class="p">}</span>

<span class="k">let</span> <span class="nv">_</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: argument labels '(_:)' do not match any available overloads`
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: missing argument label 'answer:' in call
let _: [String] = [42].map { foo($0) }
                                 ^
                                 answer:
</code></pre></div></div>

<h3 id="argument-to-parameter-conversion-mismatch">Argument-to-Parameter Conversion Mismatch</h3>

<p>Consider the following invalid code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="p">(</span><span class="nv">$0</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>  <span class="o">&gt;</span> <span class="mi">42</span> <span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: binary operator '+' cannot be applied to operands of type 'Int' and 'UInt'`
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: cannot convert value of type 'UInt' to expected argument type 'Int'
_ = x.filter { ($0 + y)  &gt; 42 }
                     ^
                     Int( )
</code></pre></div></div>

<h3 id="invalid-optional-unwrap">Invalid Optional Unwrap</h3>

<p>Consider the following invalid code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">S</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">_</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">_</span> <span class="o">=</span> <span class="kt">S</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">([</span><span class="n">i</span><span class="o">!</span><span class="p">])</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: type of expression is ambiguous without more context
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: cannot force unwrap value of non-optional type 'Int'
_ = S&lt;Int&gt;([i!])
            ~^
</code></pre></div></div>

<h3 id="missing-members">Missing Members</h3>

<p>Consider the following invalid code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">A</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="kt">B</span> <span class="p">:</span> <span class="kt">A</span> <span class="p">{</span>
  <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">A</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">A</span><span class="p">()</span> 
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">S</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">T</span><span class="o">...</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="n">bar</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">t</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">_</span> <span class="o">=</span> <span class="kt">S</span><span class="p">(</span><span class="kt">B</span><span class="p">(),</span> <span class="o">.</span><span class="nf">foo</span><span class="p">(),</span> <span class="kt">A</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: generic parameter ’T’ could not be inferred
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: type 'A' has no member 'foo'
    _ = S(B(), .foo(), A())
               ~^~~~~
</code></pre></div></div>

<h3 id="missing-protocol-conformance">Missing Protocol Conformance</h3>

<p>Consider the following invalid code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">P</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="n">foo</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="n">bar</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: generic parameter 'T' could not be inferred
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: argument type 'T' does not conform to expected type 'P'
    return foo(x)
               ^
</code></pre></div></div>

<h3 id="conditional-conformances">Conditional Conformances</h3>

<p>Consider the following invalid code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">BinaryInteger</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">self</span> <span class="o">&lt;=</span> <span class="mi">1</span>
      <span class="p">?</span> <span class="mi">1</span>
      <span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="o">...</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: ambiguous reference to member '...'
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: referencing instance method 'reduce' on 'ClosedRange' requires that 'Self.Stride' conform to 'SignedInteger'
      : (2...self).reduce(1, *)
                   ^
Swift.ClosedRange:1:11: note: requirement from conditional conformance of 'ClosedRange&lt;Self&gt;' to 'Sequence'
extension ClosedRange : Sequence where Bound : Strideable, Bound.Stride : SignedInteger {
          ^
</code></pre></div></div>

<h2 id="swiftui-examples">SwiftUI Examples</h2>

<h3 id="argument-to-parameter-conversion-mismatch-1">Argument-to-Parameter Conversion Mismatch</h3>

<p>Consider the following invalid SwiftUI code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">Foo</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">ForEach</span><span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">Circle</span><span class="p">()</span><span class="o">.</span><span class="nf">rotation</span><span class="p">(</span><span class="o">.</span><span class="nf">degrees</span><span class="p">(</span><span class="nv">$0</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: Cannot convert value of type '(Double) -&gt; RotatedShape&lt;Circle&gt;' to expected argument type '() -&gt; _'
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: cannot convert value of type 'Int' to expected argument type 'Double'
        Circle().rotation(.degrees($0))
                                   ^
                                   Double( )
</code></pre></div></div>

<h3 id="missing-members-1">Missing Members</h3>

<p>Consider the following invalid SwiftUI code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">S</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">ZStack</span> <span class="p">{</span>
      <span class="kt">Rectangle</span><span class="p">()</span><span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mf">220.0</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mf">32.0</span><span class="p">)</span>
                 <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="o">.</span><span class="n">systemRed</span><span class="p">)</span>

      <span class="kt">HStack</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span>
        <span class="kt">Spacer</span><span class="p">()</span>
        <span class="kt">Text</span><span class="p">(</span><span class="s">"B"</span><span class="p">)</span>
      <span class="p">}</span><span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
    <span class="p">}</span><span class="o">.</span><span class="nf">scaledToFit</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Previously, this used to be diagnosed as a completely unrelated problem:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: 'Double' is not convertible to 'CGFloat?'
      Rectangle().frame(width: 220.0, height: 32.0)
                               ^~~~~
</code></pre></div></div>

<p>The new diagnostic now correctly points out that there is no such color as <code class="language-plaintext highlighter-rouge">systemRed</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: type 'Color?' has no member 'systemRed'
                   .foregroundColor(.systemRed)
                                    ~^~~~~~~~~
</code></pre></div></div>

<h3 id="missing-arguments">Missing arguments</h3>

<p>Consider the following invalid SwiftUI code:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">struct</span> <span class="kt">S</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">showDetail</span> <span class="o">=</span> <span class="kc">false</span>

  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
      <span class="k">self</span><span class="o">.</span><span class="n">showDetail</span><span class="o">.</span><span class="nf">toggle</span><span class="p">()</span>
    <span class="p">})</span> <span class="p">{</span>
     <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"chevron.right.circle"</span><span class="p">)</span>
       <span class="o">.</span><span class="nf">imageScale</span><span class="p">(</span><span class="o">.</span><span class="n">large</span><span class="p">)</span>
       <span class="o">.</span><span class="nf">rotationEffect</span><span class="p">(</span><span class="o">.</span><span class="nf">degrees</span><span class="p">(</span><span class="n">showDetail</span> <span class="p">?</span> <span class="mi">90</span> <span class="p">:</span> <span class="mi">0</span><span class="p">))</span>
       <span class="o">.</span><span class="nf">scaleEffect</span><span class="p">(</span><span class="n">showDetail</span> <span class="p">?</span> <span class="mf">1.5</span> <span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
       <span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
       <span class="o">.</span><span class="nf">animation</span><span class="p">(</span><span class="o">.</span><span class="n">spring</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Previously, this resulted in the following diagnostic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: type of expression is ambiguous without more context
</code></pre></div></div>

<p>This is now diagnosed as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error: member 'spring' expects argument of type '(response: Double, dampingFraction: Double, blendDuration: Double)'
         .animation(.spring)
                     ^
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>The new diagnostic infrastructure is designed to overcome all of the shortcomings of the old approach. The way it’s structured is intended to make it easy to improve/port existing diagnostics and to be used by new feature implementors to provide great diagnostics right off the bat. It shows very promising results with all of the diagnostics we have ported so far, and we are hard at work porting more every day.</p>

<h3 id="questions">Questions?</h3>

<p>Please feel free to post questions about this post on the <a href="https://forums.swift.org/t/swift-org-blog-new-diagnostic-architecture-overview/29905">associated thread</a> on the <a href="https://forums.swift.org">Swift forums</a>.</p>



  
  <footer>
    <nav>
      
      <a href="/blog/5.2-release-process/" rel="prev" title="Previous: Swift 5.2 Release Process">Swift 5.2 Release Process</a>
      

      
      <a href="/blog/sswg-update-2019/" rel="next" title="Next: SSWG Annual Update">SSWG Annual Update</a>
      
    </nav>
  </footer>
  
</article>
</main>



<footer role="contentinfo">
  <div class="footer-content">
    
  <p>Except where otherwise noted, all content on this blog is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a>.</p>

    <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
    <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
    <p class="privacy">
      <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
      <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
    </p>
  </div>
  <div class="footer-other">
    <form
      class="color-scheme-toggle"
      role="radiogroup"
      tabindex="0"
      id="color-scheme-toggle"
    >
      <legend class="visuallyhidden">Color scheme preference</legend>
      <label for="scheme-light">
        <input id="scheme-light" type="radio" name="color-scheme-preference" value="light">
        <span class="color-scheme-toggle-label">Light</span>
      </label>
      <label for="scheme-dark">
        <input id="scheme-dark" type="radio" name="color-scheme-preference" value="dark">
        <span class="color-scheme-toggle-label">Dark</span>
      </label>
      <label for="scheme-auto" id="scheme-auto-wrapper">
        <input id="scheme-auto" type="radio" name="color-scheme-preference" value="auto">
        <span class="color-scheme-toggle-label">Auto</span>
      </label>
    </form>
    <aside>
      <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter"></i></a>
      <a href="/atom.xml" title="Subscribe to Site Updates"><i class="feed"></i></a>
    </aside>
  </div>
</footer>


<script src="/assets/javascripts/application.js"></script>
<!-- metrics -->
<script>
    /* RSID: */
    var s_account="awdswiftorg"
</script>
<script src="https://developer.apple.com/assets/metrics/scripts/analytics.js"></script>
<script>
    s.pageName= AC && AC.Tracking && AC.Tracking.pageName();

    /************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
    var s_code=s.t();if(s_code)document.write(s_code)
</script>
<!-- /metrics -->
</body>
</html>
